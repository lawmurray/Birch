/**
 * Element-wise addition.
 */
operator (x:NumberLike + y:NumberLike) -> NumberLike;

operator<Arg1,Arg2> (x:VectorFill<Arg1> + y:Arg2) -> {
  ///@todo Check for compatible sizes
  return x.m + y;
}

operator<Arg1,Arg2> (x:Arg1 + y:VectorFill<Arg2>) -> {
  ///@todo Check for compatible sizes
  return x + y.m;
}

operator<Arg1,Arg2> (x:MatrixFill<Arg1> + y:Arg2) -> {
  ///@todo Check for compatible sizes
  return x.m + y;
}

operator<Arg1,Arg2> (x:Arg1 + y:MatrixFill<Arg2>) -> {
  ///@todo Check for compatible sizes
  return x + y.m;
}

/**
 * Element-wise logical `and`.
 */
operator (x:NumberLike && y:NumberLike) -> BooleanLike;

/**
 * Element-wise division.
 */
operator (x:NumberLike/y:NumberLike) -> NumberLike;

/**
 * Element-wise equal to comparison.
 */
operator (x:NumberLike == y:NumberLike) -> BooleanLike;

/**
 * Element-wise greater than comparison.
 */
operator (x:NumberLike > y:NumberLike) -> BooleanLike;

/**
 * Element-wise greater than or equal to comparison.
 */
operator (x:NumberLike >= y:NumberLike) -> BooleanLike;

/**
 * Element-wise less than comparison.
 */
operator (x:NumberLike < y:NumberLike) -> BooleanLike;

/**
 * Element-wise less than or equal to comparison.
 */
operator (x:NumberLike <= y:NumberLike) -> BooleanLike;

/**
 * Element-wise not equal to comparison.
 */
operator (x:NumberLike != y:NumberLike) -> BooleanLike;

/**
 * Scalar multiplication.
 */
operator (x:NumberScalarLike*y:NumberLike) -> NumberLike;

/**
 * Scalar multiplication.
 */
operator (x:NumberLike*y:NumberScalarLike) -> NumberLike;

/**
 * Matrix-vector multiplication.
 */
operator (A:RealMatrixLike*x:RealVectorLike) -> RealVectorLike;

/**
 * Matrix-matrix multiplication.
 */
operator (A:RealMatrixLike*B:RealMatrixLike) -> RealMatrixLike;

operator<Arg1,Arg2> (A:ScalarDiagonal<Arg1>*B:Arg2) -> {
  ///@todo Check for compatible sizes
  return A.m*B;
}

operator<Arg1,Arg2> (A:Arg1*B:ScalarDiagonal<Arg2>) -> {
  ///@todo Check for compatible sizes
  return A*B.m;
}

operator<Arg1,Arg2> (A:ScalarDiagonal<Arg1>*B:ScalarDiagonal<Arg2>) -> {
  assert A.n == B.n;
  return diagonal(A.m*B.m, A.n);
}

/**
 * Element-wise logical `or`.
 */
operator (x:NumberLike || y:NumberLike) -> BooleanLike;

/**
 * Element-wise subtraction.
 */
operator (x:NumberLike - y:NumberLike) -> NumberLike;

operator<Arg1,Arg2> (x:VectorFill<Arg1> - y:Arg2) -> {
  ///@todo Check for compatible sizes
  return x.m - y;
}

operator<Arg1,Arg2> (x:Arg1 - y:VectorFill<Arg2>) -> {
  ///@todo Check for compatible sizes
  return x - y.m;
}

operator<Arg1,Arg2> (x:MatrixFill<Arg1> - y:Arg2) -> {
  ///@todo Check for compatible sizes
  return x.m - y;
}

operator<Arg1,Arg2> (x:Arg1 - y:MatrixFill<Arg2>) -> {
  ///@todo Check for compatible sizes
  return x - y.m;
}

/**
 * Matrix-scalar solve via the Cholesky factorization.
 * 
 * @param L Lower-triangular Cholesky factor $L$ of the symmetric positive
 * definite matrix $S = LL^\top$.
 * @param y Scalar $y$.
 * 
 * @return Solution of $B$ in $SB = LL^\top B = Iy$.
 */
function cholsolve(L:RealMatrixLike, y:RealScalarLike) -> RealMatrixLike;

/**
 * Matrix-vector solve via the Cholesky factorization.
 * 
 * @param L Lower-triangular Cholesky factor $L$ of the symmetric positive
 * definite matrix $S = LL^\top$.
 * @param y Vector $y$.
 * 
 * @return Solution of $x$ in $Sx = LL^\top x = y$.
 */
function cholsolve(L:RealMatrixLike, y:RealVectorLike) -> RealVectorLike;

/**
 * Matrix-matrix solve via the Cholesky factorization.
 * 
 * @param L Lower-triangular Cholesky factor $L$ of the symmetric positive
 * definite matrix $S = LL^\top$.
 * @param C Matrix $C$.
 * 
 * @return Solution of $B$ in $SB = LL^\top B = C$.
 */
function cholsolve(L:RealMatrixLike, y:RealMatrixLike) -> RealMatrixLike;

function cholsolve<Arg1,Arg2>(L:ScalarDiagonal<Arg1>, y:Arg2) -> {
  ///@todo Check for compatible sizes
  return y/pow(L.m, 2.0);
}

function cholsolve<Arg1,Arg2>(L:VectorDiagonal<Arg1>, y:Arg2) -> {
  ///@todo Check for compatible sizes
  return y/pow(L.m, 2.0);
}

/**
 * Convolve probabilities for the sum of two discrete random variables.
 */
function convolve(p:RealVectorLike, q:RealVectorLike) -> RealVectorLike;

/**
 * Copy sign.
 * 
 * @param x Argument.
 * @param y Argument.
 * 
 * @return Result with the absolute values of @p x but signs of @p y.
 */
function copysign(x:NumberLike, y:NumberLike) -> NumberLike;

/**
 * Vector-vector dot product.
 * 
 * @param x Vector $x$.
 * @param y Vector $y$.
 * 
 * @return Result $x^\top y$ as a scalar.
 */
function dot(x:RealVectorLike, y:RealVectorLike) -> RealScalarLike;

/**
 * Matrix-matrix Frobenius product.
 * 
 * @param A Matrix $A$.
 * @param B Matrix $B$.
 * 
 * @return Result $\langle A, B \rangle_\mathrm{F} = \mathrm{Tr}(A^\top B) =
 * \sum_{ij} A_{ij} B_{ij}$ as a scalar.
 */
function frobenius(A:RealMatrixLike, B:RealMatrixLike) -> RealScalarLike;

/**
 * Element-wise multiplication (Hadamard product).
 */
function hadamard(x:NumberLike, y:NumberLike) -> NumberLike;

/**
 * Matrix-vector inner product.
 * 
 * @param A Matrix $A$.
 * @param x Vector $x$.
 * 
 * @return Result $y = A^\top x$.
 */
function inner(A:RealMatrixLike, x:RealVectorLike) -> RealVectorLike;

/**
 * Matrix-matrix inner product.
 * 
 * @param A Matrix $A$.
 * @param B Matrix $B$.
 * 
 * @return Result $C = A^\top B$.
 */
function inner(A:RealMatrixLike, x:RealMatrixLike) -> RealMatrixLike;

/**
 * Logarithm of the beta function.
 */
function lbeta(x:NumberLike, y:NumberLike) -> RealLike;

/**
 * Logarithm of the binomial coefficient.
 */
function lbinomial(n:NumberLike, k:NumberLike) -> RealLike;

/**
 * Logarithm of the multivariate gamma function.
 */
function lgamma(x:NumberLike, p:NumberLike) -> RealLike;

/**
 * Pack two arrays next to each other, concatenating their rows.
 * 
 * @param x Argument.
 * @param y Argument.
 * 
 * @return Result.
 * 
 * @p x and @p y must have the same number of rows. The result has this
 * number of rows, and a number of columns equal to the number of columns
 * of @p x plus the number of columns of @p y.
 */
function pack(x:NumberLike, y:NumberLike) -> NumberMatrixLike;

/**
 * Stack two arrays atop one another, concatenating their columns.
 * 
 * @param x Argument.
 * @param y Argument.
 * 
 * @return Result.
 * 
 * @p x and @p y must have the same number of columns. The result has this
 * number of columns, and a number of rows equal to the number of rows of @p x
 * plus the number of rows of @p y. The result has two dimensions if at least
 * one of the arguments has two dimensions, and one dimension otherwise.
 */
function stack(x:NumberLike, y:NumberLike) -> NumberLike;

/**
 * Vector-vector outer product.
 * 
 * @param x Vector $x$.
 * @param y Vector $y$.
 * 
 * @return Result $C = xy^\top$.
 */
function outer(x:RealVectorLike, y:RealVectorLike) -> RealMatrixLike;

/**
 * Matrix-matrix outer product.
 * 
 * @param A Matrix $A$.
 * @param B Matrix $B$.
 * 
 * @return Result $C = AB^\top$.
 */
function outer(A:RealMatrixLike, B:RealMatrixLike) -> RealMatrixLike;

/**
 * Power.
 */
function pow(x:NumberLike, y:NumberLike) -> NumberLike;

/**
 * Vector scatter.
 */
function scatter(x:NumberVectorLike, y:IntegerVectorLike, n:Integer) ->
    NumberVectorLike;

/**
 * Construct single-entry vector. A given element of the vector has a given
 * value, all others are zero.
 * 
 * @param x Value of single entry.
 * @param i Index of single entry.
 * @param n Length of vector.
 * 
 * @return Single-entry vector.
 */
function single(x:NumberScalarLike, i:IntegerScalarLike, n:Integer) ->
    NumberVectorLike;

/**
 * Lower-triangular-matrix-vector inner product.
 * 
 * @param L Lower-triangular matrix $L$.
 * @param x Vector $x$.
 * 
 * @return Result $y = Lx$.
 */
function triinner(L:RealMatrixLike, y:RealVectorLike) -> RealVectorLike;

/**
 * Lower-triangular-matrix-matrix inner product.
 * 
 * @param L Lower-triangular matrix $L$.
 * @param B Matrix $B$.
 * 
 * @return Result $C = L^\top B$.
 */
function triinner(L:RealMatrixLike, B:RealMatrixLike) -> RealMatrixLike;

function triinner<Arg1,Arg2>(A:ScalarDiagonal<Arg1>, B:Arg2) -> {
  ///@todo Check for compatible sizes
  return A.m*B;
}

function triinner<Arg1,Arg2>(A:Arg1, B:ScalarDiagonal<Arg2>) -> {
  ///@todo Check for compatible sizes
  return transpose(A)*B.m;
}

function triinner<Arg1,Arg2>(A:ScalarDiagonal<Arg1>, B:ScalarDiagonal<Arg2>) -> {
  assert A.n == B.n;
  return diagonal(A.m*B.m, A.n);
}

/**
 * Lower-triangular-matrix-scalar inner solve.
 * 
 * @param L Lower-triangular matrix $L$.
 * @param y Scalar $y$.
 * 
 * @return Solution of $B$ in $LB = Iy$.
 */
function triinnersolve(L:RealMatrixLike, y:RealScalarLike) -> RealMatrixLike; 

/**
 * Lower-triangular-matrix-vector inner solve.
 * 
 * @param L Lower-triangular matrix $L$.
 * @param y Vector $y$.
 * 
 * @return Solution of $x$ in $y = L^\top x$.
 */
function triinnersolve(L:RealMatrixLike, y:RealVectorLike) -> RealVectorLike;

/**
 * Lower-triangular-matrix-matrix inner solve.
 * 
 * @param L Lower-triangular matrix $L$.
 * @param C Matrix $C$.
 * 
 * @return Solution of $B$ in $C = L^\top B$.
 */
function triinnersolve(L:RealMatrixLike, C:RealMatrixLike) -> RealMatrixLike;

/**
 * Lower-triangular-matrix-vector product.
 * 
 * @param L Lower-triangular matrix $L$.
 * @param x Vector $x$.
 * 
 * @return Result $y = Lx$.
 */
function trimul(L:RealMatrixLike, x:RealVectorLike) -> RealVectorLike;

/**
 * Lower-triangular-matrix-matrix product.
 * 
 * @param L Lower-triangular matrix $L$.
 * @param B Matrix $B$.
 * 
 * @return Result $C = LB$.
 */
function trimul(L:RealMatrixLike, B:RealMatrixLike) -> RealMatrixLike;

function trimul<Arg1,Arg2>(A:ScalarDiagonal<Arg1>, B:Arg2) -> {
  ///@todo Check for compatible sizes
  return A.m*B;
}

function trimul<Arg1,Arg2>(A:Arg1, B:ScalarDiagonal<Arg2>) -> {
  ///@todo Check for compatible sizes
  return A*B.m;
}

function trimul<Arg1,Arg2>(A:ScalarDiagonal<Arg1>, B:ScalarDiagonal<Arg2>) -> {
  assert A.n == B.n;
  return diagonal(A.m*B.m, A.n);
}

/**
 * Matrix-lower-triangular-matrix outer product.
 * 
 * @param A Matrix $A$.
 * @param L Lower-triangular matrix $L$.
 * 
 * @return Result $C = AL^\top$.
 */
function triouter(A:RealMatrixLike, L:RealMatrixLike) -> RealMatrixLike;

function triouter<Arg1,Arg2>(A:ScalarDiagonal<Arg1>, B:Arg2) -> {
  ///@todo Check for compatible sizes
  return A.m*transpose(B);
}

function triouter<Arg1,Arg2>(A:Arg1, B:ScalarDiagonal<Arg2>) -> {
  ///@todo Check for compatible sizes
  return A*B.m;
}

function triouter<Arg1,Arg2>(A:ScalarDiagonal<Arg1>, B:ScalarDiagonal<Arg2>) -> {
  assert A.n == B.n;
  return diagonal(A.m*B.m, A.n);
}

/**
 * Lower-triangular-matrix-scalar solve.
 * 
 * @param L Lower-triangular matrix $L$.
 * @param y Scalar $y$.
 * 
 * @return Solution of $B$ in $LB = Iy$.
 */
function trisolve(L:RealMatrixLike, y:RealScalarLike) -> RealMatrixLike;

/**
 * Lower-triangular-matrix-vector solve.
 * 
 * @param L Lower-triangular matrix $L$.
 * @param y Vector $y$.
 * 
 * @return Solution of $x$ in $Lx = y$.
 */
function trisolve(L:RealMatrixLike, y:RealVectorLike) -> RealVectorLike;

/**
 * Lower-triangular-matrix-matrix solve.
 * 
 * @param L Lower-triangular matrix $L$.
 * @param C Matrix $C$.
 * 
 * @return Solution of $B$ in $LB = C$.
 */
function trisolve(L:RealMatrixLike, y:RealMatrixLike) -> RealMatrixLike;

function trisolve<Arg1,Arg2>(L:ScalarDiagonal<Arg1>, y:Arg2) -> {
  ///@todo Check for compatible sizes
  return y/L.m;
}

/**
 * Element of a vector.
 * 
 * @param x Vector.
 * @param i Index.
 * 
 * @return Element.
 */
function element(x:NumberVectorLike, i:IntegerScalarLike) -> NumberScalarLike;

/**
 * Vector gather.
 */
function gather(x:NumberVectorLike, y:IntegerVectorLike) -> NumberVectorLike;

