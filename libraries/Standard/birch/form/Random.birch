/**
 * Random variate.
 *
 * @tparam Value Value type.
 */
struct Random<Value> {
  phantom x;
  phantom p;

  hpp{{
  /**
   * Variate value.
   */
  std::optional<numbirch::Future<Value>> x;

  /**
   * Distribution.
   */
  std::optional<Distribution<Value>> p;

  BIRCH_UNARY_SIZE(Random)

  operator auto() const {
    if (hasDistribution()) {
      return getDistribution()->variate();
    } else {
      assert(x.has_value());
      return *x;
    }
  }

  auto operator*() const {
    if (hasDistribution()) {
      return wait(getDistribution()->variate());
    } else {
      assert(x.has_value());
      return wait(*x);
    }
  }

  /**
   * Copy assignment.
   */
  Random& operator=(const Random& o) {
    if (o.hasDistribution()) {
      setDistribution(o.getDistribution());
    } else {
      this->x = o.x;
    }
    return *this;
  }

  /**
   * Value assignment.
   */
  Random& operator=(const numbirch::Future<Value>& x) {
    assert(!this->x.has_value());
    if (hasDistribution()) {
      getDistribution()->assign(x);
    } else {
      this->x = x;
    }
    return *this;
  }

  /**
   * Does this have a value?
   */
  bool hasValue() const {
    return x.has_value() || (hasDistribution() &&
        getDistribution()->hasValue());
  }

  /**
   * Does this have a distribution?
   */
  bool hasDistribution() const {
    return p.has_value();
  }

  /**
   * Get the distribution.
   */
  auto getDistribution() const {
    assert(hasDistribution());
    return *p;
  }

  /**
   * Set the distribution.
   *
   * @param p Distribution.
   */
  void setDistribution(const Distribution<Value>& p);

  /**
   * Does this have a marginalized distribution?
   */
  bool hasMarginalized() const {
    return hasDistribution() && getDistribution()->hasMarginalized();
  }

  /**
   * Get the marginalized distribution.
   */
  Delay getMarginalized() const {
    assert(hasMarginalized());
    return getDistribution()->getMarginalized();
  }
 
  auto value() const {
    if (hasDistribution()) {
      return getDistribution()->variate();
    } else {
      assert(x.has_value());
      return *x;
    }
  }

  auto eval() const {
    if (hasDistribution()) {
      return getDistribution()->variateLazy();
    } else {
      assert(x.has_value());
      return *x;
    }
  }

  auto peek() const {
    if (hasDistribution()) {
      return getDistribution()->variateLazy();
    } else {
      assert(x.has_value());
      return *x;
    }
  }

  auto move(const MoveVisitor& visitor) const {
    if (hasDistribution()) {
      return getDistribution()->move(visitor);
    } else {
      assert(x.has_value());
      return *x;
    }
  }

  void reset() {
    if (hasDistribution()) {
      getDistribution()->reset();
    }
  }

  void relink(const RelinkVisitor& visitor) {
    if (hasDistribution()) {
      getDistribution()->relink(visitor);
    }
  }

  void constant() {
    if (hasDistribution()) {
      x = getDistribution()->variate();
    }
    assert(x.has_value());
    p.reset();
  }

  void constant() const {
    const_cast<Random*>(this)->constant();
  }

  bool isConstant() const {
    return !hasDistribution() || getDistribution()->isConstant();
  }

  void args(const ArgsVisitor& visitor) const {
    if (hasDistribution()) {
      getDistribution()->args(visitor);
    }
  }

  void deepGrad(const GradVisitor& visitor) const {
    //
  }

  template<class G>
  void shallowGrad(const G& g, const GradVisitor& visitor) const {
    if (hasDistribution()) {
      getDistribution()->grad(g, visitor);
      const_cast<Random*>(this)->x.reset();
    }
  }

  Delay graft() const {
    assert(hasDistribution());
    return *getDistribution()->graft();
  }

  bool isGaussian() const {
    return hasDistribution() && getDistribution()->getUpdated()->isGaussian();
  }

  bool isBeta() const {
    return hasDistribution() && getDistribution()->getUpdated()->isBeta();
  }

  bool isGamma() const {
    return hasDistribution() && getDistribution()->getUpdated()->isGamma();
  }

  bool isInverseGamma() const {
    return hasDistribution() && getDistribution()->getUpdated()->isInverseGamma();
  }

  bool isInverseWishart() const {
    return hasDistribution() && getDistribution()->getUpdated()->isInverseWishart();
  }

  bool isNormalInverseGamma() const {
    return hasDistribution() && getDistribution()->getUpdated()->isNormalInverseGamma();
  }

  bool isDirichlet() const {
    return hasDistribution() && getDistribution()->getUpdated()->isDirichlet();
  }

  bool isMultivariateGaussian() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMultivariateGaussian();
  }

  bool isMultivariateNormalInverseGamma() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMultivariateNormalInverseGamma();
  }

  bool isMultivariateNormalInverseWishart() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMultivariateNormalInverseWishart();
  }

  bool isMultivariateNormalWishart() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMultivariateNormalWishart();
  }

  bool isMatrixGaussian() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMatrixGaussian();
  }

  bool isMatrixNormalInverseWishart() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMatrixNormalInverseWishart();
  }

  bool isBoundedDiscrete() const {
    return hasDistribution() && getDistribution()->getUpdated()->isBoundedDiscrete();
  }

  void read(const Buffer& buffer);
  void read(const Integer t, const Buffer& buffer);
  void write(const Buffer& buffer);
  void write(const Integer t, const Buffer& buffer);
  }}

  cpp{{
  template<class Value>
  void Random<Value>::setDistribution(const Distribution<Value>& p) {
    assert(!hasDistribution());
    this->p = p;
    if (x) {
      getDistribution()->assign(*x);
    } else if (!get_handler()->autoconj) {
      getDistribution()->realize();
    }
  }

  template<class Value>
  void Random<Value>::read(const Buffer& buffer) {
    optional_assign(*this, buffer->get<Value>());
  }

  template<class Value>
  void Random<Value>::read(const Integer t, const Buffer& buffer) {
    return read(buffer);
  }

  template<class Value>
  void Random<Value>::write(const Buffer& buffer) {
    if (x || p) {
      buffer->set(value(*this));
    } else {
      buffer->setNil();
    }
  }

  template<class Value>
  void Random<Value>::write(const Integer t, const Buffer& buffer) {
    return write(buffer);
  }
  }}
}

hpp{{
namespace birch {

template<class Value>
struct is_form<Random<Value>> {
  static constexpr bool value = true;
};

template<class Value>
struct tag_s<Random<Value>> {
  using type = Random<Value>;
};

template<class Value>
struct peg_s<Random<Value>> {
  using type = Random<Value>;
};

}
}}
