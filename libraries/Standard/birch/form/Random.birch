/**
 * Random variate.
 *
 * @tparam Value Value type.
 */
struct Random<Value> {
  phantom x;
  phantom p;

  hpp{{
  /**
   * Variate value.
   */
  std::optional<numbirch::Future<Value>> x;

  /**
   * Distribution.
   */
  std::optional<Distribution<Value>> p;

  operator auto() const {
    if (hasDistribution()) {
      return getDistribution()->variate();
    } else {
      assert(x.has_value());
      return *x;
    }
  }

  auto operator*() const {
    if (hasDistribution()) {
      return wait(getDistribution()->variate());
    } else {
      assert(x.has_value());
      return wait(*x);
    }
  }

  /**
   * Copy assignment.
   */
  Random& operator=(const Random& o) {
    if (o.hasDistribution()) {
      setDistribution(*o.p);
    } else {
      this->x = o.x;
    }
    return *this;
  }

  /**
   * Value assignment.
   */
  Random& operator=(const numbirch::Future<Value>& x) {
    assert(!this->x.has_value());
    if (hasDistribution()) {
      getDistribution()->assign(x);
    }
    this->x = x;
    return *this;
  }

  /**
   * Does this have a value?
   */
  bool hasValue() const {
    return x.has_value() || (hasDistribution() &&
        getDistribution()->hasValue());
  }

  /**
   * Does this have a distribution?
   */
  bool hasDistribution() const {
    return p.has_value();
  }

  /**
   * Get the distribution.
   */
  auto getDistribution() const {
    assert(hasDistribution());
    return *p;
  }

  /**
   * Set the distribution.
   *
   * @param p Distribution.
   */
  void setDistribution(const Distribution<Value>& p);

  /**
   * Does this have a marginalized distribution?
   */
  bool hasMarginalized() const {
    return hasDistribution() && getDistribution()->hasMarginalized();
  }

  /**
   * Get the marginalized distribution.
   */
  Delay getMarginalized() const {
    assert(hasMarginalized());
    return getDistribution()->getMarginalized();
  }
 
  Delay graft() const {
    assert(hasDistribution());
    return *getDistribution()->graft();
  }

  bool isGaussian() const {
    return hasDistribution() && getDistribution()->getUpdated()->isGaussian();
  }

  bool isBeta() const {
    return hasDistribution() && getDistribution()->getUpdated()->isBeta();
  }

  bool isGamma() const {
    return hasDistribution() && getDistribution()->getUpdated()->isGamma();
  }

  bool isInverseGamma() const {
    return hasDistribution() && getDistribution()->getUpdated()->isInverseGamma();
  }

  bool isInverseWishart() const {
    return hasDistribution() && getDistribution()->getUpdated()->isInverseWishart();
  }

  bool isNormalInverseGamma() const {
    return hasDistribution() && getDistribution()->getUpdated()->isNormalInverseGamma();
  }

  bool isDirichlet() const {
    return hasDistribution() && getDistribution()->getUpdated()->isDirichlet();
  }

  bool isRestaurant() const {
    return hasDistribution() && getDistribution()->getUpdated()->isRestaurant();
  }

  bool isMultivariateGaussian() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMultivariateGaussian();
  }

  bool isMultivariateNormalInverseGamma() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMultivariateNormalInverseGamma();
  }

  bool isMultivariateNormalInverseWishart() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMultivariateNormalInverseWishart();
  }

  bool isMultivariateNormalWishart() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMultivariateNormalWishart();
  }

  bool isMatrixGaussian() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMatrixGaussian();
  }

  bool isMatrixNormalInverseWishart() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMatrixNormalInverseWishart();
  }

  bool isBoundedDiscrete() const {
    return hasDistribution() && getDistribution()->getUpdated()->isBoundedDiscrete();
  }

  void read(const Buffer& buffer);
  void read(const Integer t, const Buffer& buffer);
  void write(const Buffer& buffer);
  void write(const Integer t, const Buffer& buffer);
  }}

  cpp{{
  template<class Value>
  void Random<Value>::setDistribution(const Distribution<Value>& p) {
    assert(!hasDistribution());
    this->p = p;
    if (x) {
      getDistribution()->assign(*x);
    } else if (!get_handler()->autoconj) {
      getDistribution()->realize();
    }
  }

  template<class Value>
  void Random<Value>::read(const Buffer& buffer) {
    optional_assign(*this, buffer->get<Value>());
  }

  template<class Value>
  void Random<Value>::read(const Integer t, const Buffer& buffer) {
    return read(buffer);
  }

  template<class Value>
  void Random<Value>::write(const Buffer& buffer) {
    if (x || p) {
      buffer->set(value(*this));
    } else {
      buffer->setNil();
    }
  }

  template<class Value>
  void Random<Value>::write(const Integer t, const Buffer& buffer) {
    return write(buffer);
  }
  }}
}

hpp{{
namespace birch {

template<class Value>
struct is_form<Random<Value>> {
  static constexpr bool value = true;
};

template<class Value>
int rows(const Random<Value>& o) {
  return rows(eval(o));
}

template<class Value>
int columns(const Random<Value>& o) {
  return columns(eval(o));
}

template<class Value>
int length(const Random<Value>& o) {
  return length(eval(o));
}

template<class Value>
int size(const Random<Value>& o) {
  return size(eval(o));
}

template<class Value>
auto value(const Random<Value>& o) {
  if (o.hasDistribution()) {
    return o.getDistribution()->variate();
  } else {
    assert(o.x.has_value());
    return *o.x;
  }
}

template<class Value>
auto eval(const Random<Value>& o) {
  if (o.hasDistribution()) {
    return o.getDistribution()->variateLazy();
  } else {
    assert(o.x.has_value());
    return *o.x;
  }
}

template<class Value>
auto peek(const Random<Value>& o) {
  if (o.hasDistribution()) {
    return o.getDistribution()->variateLazy();
  } else {
    assert(o.x.has_value());
    return *o.x;
  }
}

template<class Value>
auto move(const Random<Value>& o, const MoveVisitor& visitor) {
  if (o.hasDistribution()) {
    return o.getDistribution()->move(visitor);
  } else {
    assert(o.x.has_value());
    return *o.x;
  }
}

template<class Value>
auto peg(const Random<Value>& o) {
  return o;
}

template<class Value>
auto tag(const Random<Value>& o) {
  return o;
}

template<class Value>
void reset(Random<Value>& o) {
  if (o.hasDistribution()) {
    o.getDistribution()->reset();
  }
}

template<class Value>
void relink(Random<Value>& o, const RelinkVisitor& visitor) {
  if (o.hasDistribution()) {
    o.getDistribution()->relink(visitor);
  }
}

template<class Value>
void constant(Random<Value>& o) {
  if (o.hasDistribution()) {
    o.x = o.getDistribution()->variate();
  }
  assert(o.x.has_value());
  o.p.reset();
}

template<class Value>
void constant(const Random<Value>& o) {
  if (o.hasDistribution()) {
    o.getDistribution()->variate();
  }
}

template<class Value>
bool is_constant(const Random<Value>& o) {
  return !o.hasDistribution() || o.getDistribution()->isConstant();
}

template<class Value>
void args(const Random<Value>& o, const ArgsVisitor& visitor) {
  if (o.hasDistribution()) {
    o.getDistribution()->args(visitor);
  }
}

template<class Value>
void deep_grad(const Random<Value>& o, const GradVisitor& visitor) {
  //
}

template<class Value, class G>
void shallow_grad(const Random<Value>& o, const G& g, const GradVisitor& visitor) {
  if (o.hasDistribution()) {
    o.getDistribution()->grad(g, visitor);
    const_cast<Random<Value>&>(o).x.reset();
  }
}

}
}}
