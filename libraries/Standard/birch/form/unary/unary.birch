/**
 * Unary plus.
 */
operator (+x:NumberLike) -> NumberLike;

/**
 * Negation.
 */
operator (-x:NumberLike) -> NumberLike;

operator<Arg> (-x:Neg<Arg>) -> Arg {
  return x.m;
}

/**
 * Logical `not`.
 */
operator (!x:NumberLike) -> BooleanLike;

operator<Arg> (!x:Not<Arg>) -> Arg {
  return x.m;
}

/**
 * Absolute value.
 */
function abs(x:NumberLike) -> NumberLike;

function abs<Arg>(x:Abs<Arg>) -> Abs<Arg> {
  return x;
}

/**
 * Arc cosine.
 */
function acos(x:NumberLike) -> RealLike;

/**
 * Arc sine.
 */
function asin(x:NumberLike) -> RealLike;

/**
 * Arc tangent.
 */
function atan(x:NumberLike) -> RealLike;

/**
 * Cast.
 * 
 * @tparam To Element type `Real`, `Integer` or `Boolean`.
 * 
 * @param x Argument.
 * 
 * @return a copy of @p x with element type converted to @p To.
 */
function cast<To>(x:NumberLike) -> NumberLike;

/**
 * Round to smallest integer value not less than argument.
 */
function ceil(x:NumberLike) -> NumberLike;

/**
 * Cholesky factorization of a symmetric positive definite matrix.
 * 
 * @param S Symmetric positive definite matrix $S$.
 * 
 * @return Lower-triangular Cholesky factor $L$ such that $S = LL^\top$. If
 * the factorization fails, then $L$ is filled with NaN.
 */
function chol(S:RealMatrixLike) -> RealMatrixLike;

function chol<Arg>(S:ScalarDiagonal<Arg>) -> {
  return diagonal(sqrt(S.m), S.n);
}

function chol<Arg>(S:VectorDiagonal<Arg>) -> {
  return diagonal(sqrt(S.m));
}

/**
 * Inverse of a symmetric positive definite matrix via the Cholesky
 * factorization.
 * 
 * @param L Lower-triangular Cholesky factor $L$ of the symmetric positive
 * definite matrix $S = LL^\top$.
 * 
 * @return Result $S^{-1} = (LL^\top)^{-1}$.
 */
function cholinv(L:RealMatrixLike) -> RealMatrixLike;

function cholinv<Arg>(L:ScalarDiagonal<Arg>) -> {
  return diagonal(pow(L.m, -2.0), L.n);
}

function cholinv<Arg>(L:VectorDiagonal<Arg>) -> {
  return diagonal(pow(L.m, -2.0));
}

/**
 * Cosine.
 */
function cos(x:NumberLike) -> RealLike;

/**
 * Hyperbolic cosine.
 */
function cosh(x:NumberLike) -> RealLike;

/**
 * Count non-zero elements.
 */
function count(x:NumberLike) -> IntegerScalarLike;

/**
 * Construct diagonal matrix, filling the diagonal with a given scalar.
 * 
 * @param x Scalar to assign to diagonal.
 * @param n Number of rows and columns.
 * 
 * @return Diagonal matrix.
 */
function diagonal(x:NumberScalarLike, n:Integer) -> NumberMatrixLike;

/**
 * Construct diagonal matrix, setting the diagonal to a given vector.
 * 
 * @param x Vector to assign to diagonal.
 * 
 * @return Diagonal matrix.
 */
function diagonal(x:NumberVectorLike) -> NumberMatrixLike;

/**
 * Construct identity matrix.
 *
 * @param n Number of rows and columns.
 */
function identity(n:Integer) -> ScalarDiagonal<Real> {
  return diagonal(1.0, n);
}

/**
 * Vector dot product.
 * 
 * @param x Vector $x$.
 * 
 * @return Result $x^\top x$ as a scalar.
 */
function dot(x:RealVectorLike) -> RealScalarLike;

/**
 * Exponential.
 */
function exp(x:NumberLike) -> RealLike;

function exp<Arg>(x:Log<Arg>) -> Arg {
  return x.m;
}

/**
 * Exponential of argument, minus one.
 */
function expm1(x:NumberLike) -> RealLike;

function expm1<Arg>(x:Log1p<Arg>) -> Arg {
  return x.m;
}

/**
 * Round to largest integer value not greater than argument.
 */
function floor(x:NumberLike) -> NumberLike;

/**
 * Matrix Frobenius product.
 * 
 * @param A Matrix $A$.
 * 
 * @return Result $\langle A, A \rangle_\mathrm{F} = \mathrm{Tr}(A^\top A) =
 * \sum_{ij} A_{ij}^2$ as a scalar.
 */
function frobenius(A:RealMatrixLike) -> RealScalarLike;

/**
 * Matrix inner product.
 * 
 * @param A Matrix $A$.
 * 
 * @return Result $B = A^\top A$.
 */
function inner(A:RealMatrixLike) -> RealMatrixLike;

/**
 * Inverse of a square matrix.
 * 
 * @param A Square matrix $A$.
 * 
 * @return Result $B = A^{-1}$.
 */
function inv(A:RealMatrixLike) -> RealMatrixLike;

function inv<Arg>(L:ScalarDiagonal<Arg>) -> {
  return diagonal(1.0/L.m, L.n);
}

function inv<Arg>(L:VectorDiagonal<Arg>) -> {
  return diagonal(1.0/L.m);
}

function inv<Arg>(A:Inv<Arg>) -> Arg {
  return A.m;
}

/**
 * Construct a vector filled with a sequence of values increasing by one each
 * time.
 * 
 * @param x Starting value.
 * @param n Length.
 * 
 * @return Vector.
 */
function iota(x:NumberScalarLike, n:Integer) -> NumberVectorLike;

/**
 * Is value finite?
 */
function isfinite(x:NumberLike) -> BooleanLike;

/**
 * Is value infinite?
 */
function isinf(x:NumberLike) -> BooleanLike;

/**
 * Is value NaN?
 */
function isnan(x:NumberLike) -> BooleanLike;

/**
 * Logarithm of the determinant of a symmetric positive definite matrix via
 * the Cholesky factorization. The determinant of a positive definite matrix
 * is always positive, so its logarithm is defined.
 * 
 * @param L Lower-triangular Cholesky factor $L$ of the symmetric positive
 * definite matrix $S = LL^\top$.
 * 
 * @return Result $\log(\det S) = \log(\det LL^\top) = 2 \log(\det L)$.
 */
function lcholdet(L:RealMatrixLike) -> RealScalarLike;

function lcholdet<Arg>(L:ScalarDiagonal<Arg>) -> {
  return 2.0*L.n*log(L.m);
}

function lcholdet<Arg>(L:VectorDiagonal<Arg>) -> {
  return 2.0*sum(log(L.m));
}

/**
 * Logarithm of the absolute value of the determinant of a square matrix.
 * 
 * @param A Matrix $A$.
 * 
 * @return Result $\log |\det A|$.
 */
function ldet(A:RealMatrixLike) -> RealScalarLike;

function ldet<Arg>(A:ScalarDiagonal<Arg>) -> {
  return A.n*log(A.m);
}

function ldet<Arg>(A:VectorDiagonal<Arg>) -> {
  return sum(log(A.m));
}

/**
 * Logarithm of the factorial function.
 */
function lfact(x:NumberLike) -> RealLike;

/**
 * Logarithm of the gamma function.
 */
function lfact(x:NumberLike) -> RealLike;

/**
 * Logarithm of the absolute value of the determinant of a lower-triangular
 * matrix.
 * 
 * @param L Lower-triangular matrix $L$.
 * 
 * @return Result $\log|\det L|$.
 */
function ltridet(L:RealMatrixLike) -> RealScalarLike;

function ltridet<Arg>(L:ScalarDiagonal<Arg>) -> {
  return L.n*log(L.m);
}

function ltridet<Arg>(L:VectorDiagonal<Arg>) -> {
  return sum(log(L.m));
}

/**
 * Logarithm.
 */
function log(x:NumberLike) -> RealLike;

function log<Arg>(x:Exp<Arg>) -> Arg {
  return x.m;
}

/**
 * Logarithm of one plus argument.
 */
function log1p(x:NumberLike) -> RealLike;

function log1p<Arg>(x:Expm1<Arg>) -> Arg {
  return x.m;
}

/**
 * Matrixize.
 *
 * @param x Argument.
 * @param n Number of columns into which to unstack. Must be a factor of the
 * size of `x`.
 * 
 * @return If @p x is a scalar then returns a matrix with a single element. If
 * @p x is a vector then returns a matrix formed by splitting it into @p n
 * equal contiguous subvectors and unstacking them to form the columns of a
 * matrix. If @p x is a matrix then reshapes it to the given number of columns
 * as if calling `mat(vec(x), n)`.
 *
 * @see [vec](../../functions/vec), [scal](../../functions/scal)
 */
function mat(x:NumberLike, n:Integer) -> NumberMatrixLike;

/**
 * Construct a matrix filled with a given value.
 * 
 * @param x Value.
 * @param m Number of rows.
 * @param n Number of columns.
 * 
 * @return Matrix.
 */
function fill(x:NumberScalarLike, m:Integer, n:Integer) -> NumberMatrixLike;

/**
 * Vector outer product.
 * 
 * @param x Vector $x$.
 * 
 * @return Result $B = xx^\top$.
 */
function outer(x:RealVectorLike) -> RealMatrixLike;

/**
 * Matrix outer product.
 * 
 * @param A Matrix $A$.
 * 
 * @return Result $B = AA^\top$.
 */
function outer(A:RealMatrixLike) -> RealMatrixLike;

/**
 * Rectification.
 */
function rectify(x:NumberLike) -> NumberLike;

/**
 * Round to nearest integer value.
 */
function round(x:NumberLike) -> NumberLike;

/**
 * Scalarize.
 *
 * @param x Argument.
 * 
 * @return If @p x is a scalar then returns that scalar. If @p x is a vector
 * or matrix with a single element then returns that element as though a
 * slice.
 *
 * @see [mat](../../functions/mat), [vec](../../functions/vec)
 */
function scal(x:NumberLike) -> NumberScalarLike;

/**
 * Sine.
 */
function sin(x:NumberLike) -> RealLike;

/**
 * Hyperbolic sine.
 */
function sinh(x:NumberLike) -> RealLike;

/**
 * Square root.
 */
function sqrt(x:NumberLike) -> NumberLike;

/**
 * Sum elements.
 */
function sum(x:NumberLike) -> NumberScalarLike;

/**
 * Tangent.
 */
function tan(x:NumberLike) -> RealLike;

/**
 * Hyperbolic tangent.
 */
function tanh(x:NumberLike) -> RealLike;

/**
 * Matrix transpose.
 * 
 * @param A Matrix $A$.
 * 
 * @return Result $B = A^\top$.
 */
function transpose(A:RealMatrixLike) -> RealMatrixLike;

function transpose<Arg>(A:Transpose<Arg>) -> Arg {
  return A.m;
}

/**
 * Lower-triangular-matrix inner product.
 * 
 * @param L Lower-triangular matrix $L$.
 * 
 * @return Result $S = L^\top L$.
 */
function triinner(L:RealMatrixLike) -> RealMatrixLike;

/**
 * Inverse of a triangular matrix.
 * 
 * @param L Lower-triangular matrix $L$.
 * 
 * @return Result $L^{-1}$.
 */
function triinv(L:RealMatrixLike) -> RealMatrixLike;

function triinv<Arg>(L:ScalarDiagonal<Arg>) -> {
  return diagonal(1.0/L.m, L.n);
}

function triinv<Arg>(L:VectorDiagonal<Arg>) -> {
  return diagonal(1.0/L.m);
}

function triinv<Arg>(A:TriInv<Arg>) -> Arg {
  return A.m;
}

/**
 * Lower-triangular-matrix outer product.
 * 
 * @param L Lower-triangular matrix $L$.
 * 
 * @return Result $S = LL^\top$.
 */
function triouter(L:RealMatrixLike) -> RealMatrixLike;

/**
 * Vectorize.
 *
 * @param x Argument.
 * 
 * @return If @p x is a scalar then returns a vector with a single element. If
 * @p x is a vector then returns it as-is. If @p x is a matrix then forms a
 * vector by stacking its columns atop one another.
 *
 * @see [mat](../../functions/mat), [scal](../../functions/scal)
 */
function vec(x:NumberLike) -> NumberVectorLike;

/**
 * Construct a vector filled with a given value.
 * 
 * @param x Value.
 * @param n Length.
 * 
 * @return Vector.
 */
function fill(x:NumberScalarLike, n:Integer) -> NumberVectorLike;
