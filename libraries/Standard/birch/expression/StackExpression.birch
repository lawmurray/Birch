/**
 * Special expression for stack() on an arbitrary number of arguments with
 * pre-allocation of the final result.
 *
 * @tparam Arg Argument type, e.g. `Real` or `Expression<Real>`.
 * @param Element Result element type, e.g. `Real`.
 */
final class StackExpression<Arg,Element> < DoExpression<Element[_]> {
  /**
   * Arguments.
   */
  m:Array<Arg>;

  /**
   * Add an argument.
   *
   * @param arg The argument.
   */
  function push(arg:Arg) {
    m.pushBack(arg);
  }

  override function doEval() {
    let R <- m.size();
    x:Element[R];
    for r in 1..R {
      let y <- global.eval(m[r]);
      cpp{{
      x.slice(r) = y;
      }}
    }
    this.x <- x;
  }

  override function doMove(visitor:MoveVisitor) {
    let R <- m.size();
    x:Element[R];
    for r in 1..R {
      let y <- global.move(m[r], visitor);
      cpp{{
      x.slice(r) = y;
      }}
    }
    this.x <- x;
  }

  override function doArgs(visitor:ArgsVisitor) {
    let R <- m.size();
    for r in 1..R {
      global.args(m[r], visitor);
    }
  }

  override function doShallowGrad(visitor:GradVisitor) {
    let R <- m.size();
    x:Element[R];
    for r in 1..R {
      global.shallow_grad(m[r], this.g![r], visitor);
    }
  }

  override function doDeepGrad(visitor:GradVisitor) {
    let R <- m.size();
    for r in 1..R {
      global.deep_grad(m[r], visitor);
    }
  }

  override function doReset() {
    let R <- m.size();
    for r in 1..R {
      global.reset(m[r]);
    }
  }

  override function doRelink(visitor:RelinkVisitor) {
    let R <- m.size();
    for r in 1..R {
      global.relink(m[r], visitor);
    }
  }

  override function doConstant() {
    let R <- m.size();
    for r in 1..R {
      global.constant(m[r]);
    }
    m.clear();
  }
}

hpp{{
namespace birch {

template<class Arg, class Element>
struct is_expression<StackExpression<Arg,Element>> {
  static constexpr bool value = true;
};

}
}}
