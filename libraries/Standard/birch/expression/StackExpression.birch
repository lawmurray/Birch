/**
 * Special expression for stack() on an arbitrary number of arguments with
 * pre-allocation of the final result.
 *
 * @tparam Arg Argument type, e.g. `Real` or `Expression<Real>`.
 * @param Element Result element type, e.g. `Real`.
 */
final class StackExpression<Arg,Element> < Expression<Element[_]>(nil, false) {
  /**
   * Arguments.
   */
  m:Array<Arg>;

  /**
   * Add an argument.
   *
   * @param arg The argument.
   */
  function push(arg:Arg) {
    m.pushBack(arg);
  }

  override function doEval() {
    let R <- m.size();
    x:Element[R];
    for r in 1..R {
      let y <- global.eval(m[r]);
      cpp{{
      x.slice(r) = y;
      }}
    }
    this.x <- x;
  }

  override function doMove(visitor:MoveVisitor) {
    let R <- m.size();
    x:Element[R];
    for r in 1..R {
      let y <- global.move(m[r], visitor);
      cpp{{
      x.slice(r) = y;
      }}
    }
    this.x <- x;
  }

  override function doArgs(visitor:ArgsVisitor) {
    let R <- m.size();
    for r in 1..R {
      global.args(m[r], visitor);
    }
  }

  override function doShallowGrad(visitor:GradVisitor) {
    let R <- m.size();
    x:Element[R];
    for r in 1..R {
      global.shallow_grad(m[r], this.g![r], visitor);
    }
  }

  override function doDeepGrad(visitor:GradVisitor) {
    let R <- m.size();
    for r in 1..R {
      global.deep_grad(m[r], visitor);
    }
  }

  override function doReset() {
    let R <- m.size();
    for r in 1..R {
      global.reset(m[r]);
    }
  }

  override function doRelink(visitor:RelinkVisitor) {
    let R <- m.size();
    for r in 1..R {
      global.relink(m[r], visitor);
    }
  }

  override function doConstant() {
    let R <- m.size();
    for r in 1..R {
      global.constant(m[r]);
    }
    m.clear();
  }
}

hpp{{
namespace birch {

template<class Arg, class Element>
int rows(const StackExpression<Arg,Element>& o) {
  return o->rows();
}

template<class Arg, class Element>
int columns(const StackExpression<Arg,Element>& o) {
  return o->columns();
}

template<class Arg, class Element>
int length(const StackExpression<Arg,Element>& o) {
  return o->length();
}

template<class Arg, class Element>
int size(const StackExpression<Arg,Element>& o) {
  return o->size();
}

template<class Arg, class Element>
auto value(const StackExpression<Arg,Element>& o) {
  return o->value();
}

template<class Arg, class Element>
auto eval(const StackExpression<Arg,Element>& o) {
  return o->eval();
}

template<class Arg, class Element>
auto peek(const StackExpression<Arg,Element>& o) {
  return o->peek();
}

template<class Arg, class Element>
auto move(const StackExpression<Arg,Element>& o, const MoveVisitor& visitor) {
  return o->move(visitor);
}

template<class Arg, class Element>
auto peg(const StackExpression<Arg,Element>& o) {
  return o;
}

template<class Arg, class Element>
auto tag(const StackExpression<Arg,Element>& o) {
  return o;
}

template<class Arg, class Element>
void reset(StackExpression<Arg,Element>& o) {
  o->reset();
}

template<class Arg, class Element>
void relink(StackExpression<Arg,Element>& o, const RelinkVisitor& visitor) {
  o->relink(visitor);
}

template<class Arg, class Element>
void constant(const StackExpression<Arg,Element>& o) {
  o->constant();
}

template<class Arg, class Element>
bool is_constant(const StackExpression<Arg,Element>& o) {
  return o->isConstant();
}

template<class Arg, class Element>
void args(const StackExpression<Arg,Element>& o, const ArgsVisitor& visitor) {
  o->args(visitor);
}

template<class Arg, class Element>
void deep_grad(const StackExpression<Arg,Element>& o, const GradVisitor& visitor) {
  o->deepGrad(visitor);
}

template<class Arg, class Element, class G>
void shallow_grad(const StackExpression<Arg,Element>& o, const G& g, const GradVisitor& visitor) {
  o->shallowGrad(g, visitor);
}

}
}}
