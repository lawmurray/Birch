/**
 * Boxed value.
 */
final acyclic class BoxedValue<Value> < Expression<Value> {  
  hpp{{
  using Gradient = typename base_type_::Gradient;
  const numbirch::Future<Value> x;

  BoxedValue_(const numbirch::Future<Value>& x) :
      x(x) {
    //
  }
  }}

  final override function isConstant() -> Boolean {
    return true;
  }

  final override function hasValue() -> Boolean {
    return true;
  }

  final override function rows() -> Integer {
    cpp{{
    return birch::rows(x);
    }}
  }
  
  final override function columns() -> Integer {
    cpp{{
    return birch::columns(x);
    }}
  }

  final override function length() -> Integer {
    cpp{{
    return birch::length(x);
    }}
  }

  final override function size() -> Integer {
    cpp{{
    return birch::size(x);
    }}
  }

  final override function value() -> Value! {
    cpp{{
    return x;
    }}
  }

  final override function eval() -> Value! {
    cpp{{
    return x;
    }}
  }

  final function move(x:Real[_]) -> Value! {
    assert global.length(x) == 0;
    cpp{{
    return *this->x;
    }}
  }

  final override function move(visitor:MoveVisitor) -> Value! {
    cpp{{
    return x;
    }}
  }

  final override function args() -> Real[_] {
    return vector(0.0, 0);
  }

  final override function args(visitor:ArgsVisitor) {
    //
  }

  final override function grad() -> Real[_] {
    return vector(0.0, 0);
  }

  final override function grad(g:Gradient) -> Real[_] {
    return vector(0.0, 0);
  }

  final override function shallowGrad(g:Gradient, visitor:GradVisitor) {
    //
  }

  final override function deepGrad(visitor:GradVisitor) {
    //
  }

  final override function trace() {
    //
  }

  final override function reset() {
    //
  }

  final override function relink(visitor:RelinkVisitor) {
    //
  }

  final override function constant() {
    //
  }
}

hpp{{
namespace birch {

template<class Value>
struct is_expression<BoxedValue<Value>> {
  static constexpr bool value = true;
};

}
}}
