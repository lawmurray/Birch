/**
 * Boxed value.
 */
final acyclic class BoxedValue<Value>(x:Value!) < Expression<Value>(x, true) {  
  override function doEval() {
    //
  }

  override function doMove(visitor:MoveVisitor) {
    //
  }

  override function doArgs(visitor:ArgsVisitor) {
    //
  }

  override function doDeepGrad(visitor:GradVisitor) {
    //
  }

  override function doShallowGrad(visitor:GradVisitor) {
    //
  }

  override function doReset() {
    //
  }

  override function doRelink(visitor:RelinkVisitor) {
    //
  }

  override function doConstant() {
    //
  }
}

hpp{{
namespace birch {

template<class Value>
struct is_expression<BoxedValue<Value>> {
  static constexpr bool value = true;
};

template<class Value>
int rows(const BoxedValue<Value>& o) {
  return o->rows();
}

template<class Value>
int columns(const BoxedValue<Value>& o) {
  return o->columns();
}

template<class Value>
int length(const BoxedValue<Value>& o) {
  return o->length();
}

template<class Value>
int size(const BoxedValue<Value>& o) {
  return o->size();
}

template<class Value>
auto value(const BoxedValue<Value>& o) {
  return o->value();
}

template<class Value>
auto eval(const BoxedValue<Value>& o) {
  return o->eval();
}

template<class Value>
auto peek(const BoxedValue<Value>& o) {
  return o->peek();
}

template<class Value>
auto move(const BoxedValue<Value>& o, const MoveVisitor& visitor) {
  return o->move(visitor);
}

template<class Value>
auto peg(const BoxedValue<Value>& o) {
  return o;
}

template<class Value>
auto tag(const BoxedValue<Value>& o) {
  return o;
}

template<class Value>
void reset(BoxedValue<Value>& o) {
  o->reset();
}

template<class Value>
void relink(BoxedValue<Value>& o, const RelinkVisitor& visitor) {
  o->relink(visitor);
}

template<class Value>
void constant(const BoxedValue<Value>& o) {
  o->constant();
}

template<class Value>
bool is_constant(const BoxedValue<Value>& o) {
  return o->isConstant();
}

template<class Value>
void args(const BoxedValue<Value>& o, const ArgsVisitor& visitor) {
  o->args(visitor);
}

template<class Value>
void deep_grad(const BoxedValue<Value>& o, const GradVisitor& visitor) {
  o->deepGrad(visitor);
}

template<class Value, class G>
void shallow_grad(const BoxedValue<Value>& o, const G& g, const GradVisitor& visitor) {
  o->shallowGrad(g, visitor);
}

}
}}
