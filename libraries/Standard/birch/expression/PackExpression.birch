/**
 * Special expression for pack() on an arbitrary number of arguments with
 * pre-allocation of the final result.
 *
 * @tparam Arg Argument type, e.g. `Real[_]` or `Expression<Real[_]>`,
 * `Real[_]` or `Expression<Real[_,_]>`.
 * @param Element Result element type, e.g. `Real`.
 */
final class PackExpression<Arg,Element> < Expression<Element[_,_]>(nil, false) {
  /**
   * Arguments.
   */
  m:Array<Arg>;

  /**
   * Add an argument.
   *
   * @param arg The argument.
   */
  function push(arg:Arg) {
    m.pushBack(arg);
  }

  override function doEval() {
    if m.empty() {
      this.x <- matrix<Element>(0, 0, 0);
    } else {
      let R <- rows(m[1]);
      let C <- columns(m[1]);
      for k in 2..m.size() {
        assert rows(m[k]) == R;
        C <- C + columns(m[k]);
      }

      x:Element[R,C];
      let c <- 0;
      for k in 1..m.size() {
        let n <- columns(m[k]);
        x[1..R,(c + 1)..(c + n)] <- mat(global.eval(m[k]), n);
        c <- c + n;
      }
      assert c == C;
      this.x <- x;
    }
  }

  override function doMove(visitor:MoveVisitor) {
    if m.empty() {
      this.x <- matrix<Element>(0, 0, 0);
    } else {
      let R <- rows(m[1]);
      let C <- columns(m[1]);
      for k in 2..m.size() {
        assert rows(m[k]) == R;
        C <- C + columns(m[k]);
      }

      x:Element[R,C];
      let c <- 0;
      for k in 1..m.size() {
        let n <- columns(m[k]);
        x[1..R,(c + 1)..(c + n)] <- mat(global.move(m[k], visitor), n);
        c <- c + n;
      }
      assert c == C;
      this.x <- x;
    }
  }

  override function doArgs(visitor:ArgsVisitor) {
    for k in 1..m.size() {
      global.args(m[k], visitor);
    }
  }

  override function doShallowGrad(visitor:GradVisitor) {
    let R <- rows(this.g!);
    let C <- columns(this.g!);
    let c <- 0;
    for k in 1..m.size() {
      let n <- columns(m[k]);
      let g <- reshape(this.g![1..R,(c + 1)..(c + n)], eval(m[k]));
      global.shallow_grad(m[k], g, visitor);
      c <- c + n;
    }
    assert c == C;
  }

  override function doDeepGrad(visitor:GradVisitor) {
    for k in 1..m.size() {
      global.deep_grad(m[k], visitor);
    }
  }

  override function doReset() {
    for k in 1..m.size() {
      global.reset(m[k]);
    }
  }

  override function doRelink(visitor:RelinkVisitor) {
    for k in 1..m.size() {
      global.relink(m[k], visitor);
    }
  }

  override function doConstant() {
    for k in 1..m.size() {
      global.constant(m[k]);
    }
    m.clear();
  }
}

function reshape(g:Real[_,_], x:Real) -> Real! {
  return scal(g);
}

function reshape(g:Real[_,_], x:Real!) -> Real! {
  return scal(g);
}

function reshape(g:Real[_,_], x:Real[_]) -> Real[_] {
  return vec(g);
}

function reshape(g:Real[_,_], x:Real[_,_]) -> Real[_,_] {
  return g;
}

hpp{{
namespace birch {

template<class Arg, class Element>
int rows(const PackExpression<Arg,Element>& o) {
  return o->rows();
}

template<class Arg, class Element>
int columns(const PackExpression<Arg,Element>& o) {
  return o->columns();
}

template<class Arg, class Element>
int length(const PackExpression<Arg,Element>& o) {
  return o->length();
}

template<class Arg, class Element>
int size(const PackExpression<Arg,Element>& o) {
  return o->size();
}

template<class Arg, class Element>
auto value(const PackExpression<Arg,Element>& o) {
  return o->value();
}

template<class Arg, class Element>
auto eval(const PackExpression<Arg,Element>& o) {
  return o->eval();
}

template<class Arg, class Element>
auto peek(const PackExpression<Arg,Element>& o) {
  return o->peek();
}

template<class Arg, class Element>
auto move(const PackExpression<Arg,Element>& o, const MoveVisitor& visitor) {
  return o->move(visitor);
}

template<class Arg, class Element>
auto peg(const PackExpression<Arg,Element>& o) {
  return o;
}

template<class Arg, class Element>
auto tag(const PackExpression<Arg,Element>& o) {
  return o;
}

template<class Arg, class Element>
void reset(PackExpression<Arg,Element>& o) {
  o->reset();
}

template<class Arg, class Element>
void relink(PackExpression<Arg,Element>& o, const RelinkVisitor& visitor) {
  o->relink(visitor);
}

template<class Arg, class Element>
void constant(const PackExpression<Arg,Element>& o) {
  o->constant();
}

template<class Arg, class Element>
bool is_constant(const PackExpression<Arg,Element>& o) {
  return o->isConstant();
}

template<class Arg, class Element>
void args(const PackExpression<Arg,Element>& o, const ArgsVisitor& visitor) {
  o->args(visitor);
}

template<class Arg, class Element>
void deep_grad(const PackExpression<Arg,Element>& o, const GradVisitor& visitor) {
  o->deepGrad(visitor);
}

template<class Arg, class Element, class G>
void shallow_grad(const PackExpression<Arg,Element>& o, const G& g, const GradVisitor& visitor) {
  o->shallowGrad(g, visitor);
}

}
}}
