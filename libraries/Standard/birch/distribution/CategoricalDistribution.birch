/**
 * Categorical distribution.
 *
 * @param ρ Probabilities.
 */
final class CategoricalDistribution<Arg>(ρ:Arg) <
    Distribution<Integer> {
  /**
   * Category probabilities.
   */
  ρ:Arg <- ρ;

  override function simulate() -> Integer! {
    return simulate_categorical(value(ρ));
  }

  override function simulateLazy() -> Integer! {
    return simulate_categorical(eval(ρ));
  }

  override function logpdf(x:Integer!) -> Real! {
    return value(logpdf_categorical(x, ρ));
  }

  override function logpdfLazy(x:Integer!) -> Real! {
    return eval(logpdf_categorical(x, ρ));
  }

  override function hoist() -> Expression<Real> {
    return box(logpdf_categorical(random(), ρ));
  }

  override function cdf(x:Integer!) -> Real!? {
    return cdf_categorical(x, value(ρ));
  }

  override function lower() -> Integer!? {
    return 1;
  }

  override function upper() -> Integer!? {
    return length(value(ρ));
  }

  override function fix() {
    super.fix();
    constant(ρ);
  }

  override function isBoundedDiscrete() -> Boolean {
    return !x?;
  }

  override function getBoundedDiscrete() -> (Expression<Real[_]>, Integer!)? {
    assert isBoundedDiscrete();
    return (box(ρ), 1);
  }

  override function write(buffer:Buffer) {
    buffer.set("class", "Categorical");
    buffer.set("ρ", value(ρ));
  }
}

/**
 * Create categorical distribution.
 */
function Categorical<Arg>(ρ:Arg) -> Distribution<Integer> {
  return make_categorical(ρ);
}
function make_categorical<Arg>(ρ:Arg) -> {
  return peg_categorical(peg(ρ));
}
function peg_categorical<Arg>(ρ:Arg) -> {
  return CategoricalDistribution<Arg>(ρ);
}

/*
 * Simulate a categorical distribution.
 *
 * @param ρ Normalized category probabilities.
 */
function simulate_categorical<Arg1>(ρ:Arg1) -> {
  return simulate_categorical(ρ, 1.0);
}

/*
 * Simulate a categorical distribution.
 *
 * @param ρ Unnormalized category probabilities.
 * @param Z Sum of the unnormalized category probabilities.
 */
function simulate_categorical<Arg1,Arg2>(ρ:Arg1, Z:Arg2) -> {
  return count(simulate_uniform(0.0, Z) > cumsum(ρ)) + 1;
}

/*
 * Observe a categorical variate.
 *
 * @param x The variate.
 * @param ρ Normalized category probabilities.
 *
 * @return the log probability mass.
 */
function logpdf_categorical<Arg1,Arg2>(x:Arg1, ρ:Arg2) -> {
  return logpdf_categorical(x, ρ, 1.0);
}

/*
 * Observe a categorical variate.
 *
 * @param x The variate.
 * @param ρ Unnormalized category probabilities.
 * @param Z Sum of the unnormalized category probabilities.
 *
 * @return the log probability mass.
 */
function logpdf_categorical<Arg1,Arg2,Arg3>(x:Arg1, ρ:Arg2, Z:Arg3) -> {
  return log(element(ρ, x)) - log(Z);
}

/*
 * CDF of a categorical variate.
 *
 * @param x The variate.
 * @param ρ Normalized category probabilities.
 *
 * @return the cumulative probability.
 */
function cdf_categorical<Arg1,Arg2>(x:Arg1, ρ:Arg2) -> {
  return cdf_categorical(x, ρ, 1.0);
}

/*
 * CDF of a categorical variate.
 *
 * @param x The variate.
 * @param ρ Unnormalized category probabilities.
 * @param Z Sum of the unnormalized category probabilities.
 *
 * @return the cumulative probability.
 */
function cdf_categorical<Arg1,Arg2,Arg3>(x:Arg1, ρ:Arg2, Z:Arg3) -> {
  return element(cumsum(ρ), x)/Z;
}
