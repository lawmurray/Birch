/**
 * Distribution with delayed-sampling support.
 *
 * @param Value Value type.
 */
abstract class Distribution<Value> < Delay {
  /**
   * Variate
   */
  x:Value!?;

  /**
   * Accumulated gradient.
   */
  phantom g;
  hpp{{
  std::optional<numbirch::Array<Real,numbirch::Future<Value>::ndims>> g;
  }}

  /**
   * Offset into vectorized arguments.
   */
  offset:Integer <- 0;

  /**
   * Count of number of parents, set by trace().
   */
  linkCount:Integer <- 0;

  /**
   * Counter used to obtain pre- and post-order traversals of the expression
   * graph.
   */
  visitCount:Integer <- 0;

  /**
   * Is the variate pinned?
   */
  flagPinned:Boolean <- false;

  /**
   * Simulate a variate.
   *
   * @return the variate.
   */
  abstract function simulate() -> Value!;

  /**
   * Simulate a variate using lazy expressions.
   *
   * @return the variate, if supported.
   */
  abstract function simulateLazy() -> Value!;

  /**
   * Evaluate the log probability density (or mass) function at a given
   * position.
   *
   * @param x The position.
   *
   * @return the log probability density (or mass).
   */
  abstract function logpdf(x:Value!) -> Real!;

  /**
   * Evaluate the log probability density (or mass) function at a given
   * position, using lazy expressions.
   *
   * @param x The variate.
   *
   * @return the log probability density (or mass), if supported.
   */
  abstract function logpdfLazy(x:Value!) -> Real!;

  /**
   * For a compound distribution, evaluate the conditional distribution given
   * an observation.
   *
   * @param x The observation.
   */
  function update(x:Value!) -> Delay? {
    assert false;
    return nil;
  }

  /**
   * For a compound distribution, evaluate the conditional distribution given
   * an observation, using lazy expressions.
   *
   * @param x The observation.
   */
  function updateLazy(x:Random<Value>) -> Delay? {
    assert false;
    return nil;
  }

  /**
   * Evaluate the probability density (or mass) function at a given position.
   *
   * @param x The position.
   *
   * @return the probability density (or mass).
   */
  function pdf(x:Value!) -> Real! {
    return exp(logpdf(x));
  }

  /**
   * Evaluate the cumulative distribution function at a given position.
   *
   * @param x The position.
   *
   * @return the cumulative probability, if supported.
   */
  function cdf(x:Value!) -> Real!? {
    return nil;
  }

  /**
   * Evaluate the quantile function at a cumulative probability.
   *
   * @param P The cumulative probability.
   *
   * @return the quantile, if supported.
   */
  function quantile(P:Real!) -> Value!? {
    return nil;
  }
  
  /**
   * Finite lower bound of the support, if any.
   */
  function lower() -> Value!? {
    return nil;
  }
  
  /**
   * Finite upper bound of the support, if any.
   */
  function upper() -> Value!? {
    return nil;
  }

  /**
   * Get the stateful variate.
   */
  final function variate() -> Value! {
    this.graft()!.realize();
    if this.hasUpdated() {
      return this.getUpdatedDistribution().variate();
    } else {
      this.pin();
      return x!;
    }
  }

  /**
   * Get the stateful variate, using lazy expressions.
   */
  final function variateLazy() -> Value! {
    this.graft()!.realize();
    if this.hasUpdated() {
      return this.getUpdatedDistribution().variateLazy();
    } else {
      return x!;
    }
  }

  /**
   * Get the stateful variate, as a random variate.
   */
  final function random() -> Random<Value> {
    o:Random<Value>;
    o.setDistribution(this);
    return o;
  }

  final override function graft() -> Delay? {
    let p <- this;
    let p' <- this.getUpdated();
    if p'.hasMarginalized() {
      let q <- p'.getMarginalized();
      let q' <- q.graft()!;
      p'.setMarginalized(nil);
      q'.realize();

      let h <- get_handler();
      if h.autojoin && q.supportsJoin() {
        /* in this case, peg the current updated distribution for this,
         * but join the marginalized distribution to it */
        p'.setJoined(q');
      } else {
        if p'.isSecondOrder() {
          /* in this case, q' is a joint distribution over the random variable
           * associated with this distribution and the parent distribution,
           * condition it to update the parent distribution */
          p' <- q'.condition()!;
        } else {
          /* in this case, q' is just over the random variable associated with
           * this distribution, condition the original distribution to update
           * the parent distribution */
          p' <- q.condition()!;
        }
        p.setUpdated(p');
      }
    }
    assert !p'.hasMarginalized();
    return p';
  }

  final function getUpdatedDistribution() -> Distribution<Value> {
    return Distribution<Value>?(super.getUpdated())!;
  }

  final override function condition() -> Delay? {
    let h <- get_handler();
    let p <- this.getUpdatedDistribution();
    if h.autodiff {
      return updateLazy(p.random());
    } else {
      return update(p.variate());
    }
  }

  final override function realize() {
    if this.hasUpdated() {
      this.getUpdated().realize();
    } else if !this.x? {
      let h <- get_handler();
      if h.autodiff {
        h.Ξ.pushBack(this);
        this.x <- simulateLazy();
      } else {
        this.x <- simulate();
      }
      if this.hasJoined() {
        this.getJoined().setSubordinate(true);
      }
    }
  }

  final function assign(x:Value!) {
    if this.hasUpdated() {
      this.getUpdatedDistribution().assign(x);
    } else {
      assert !this.x?;
      let h <- get_handler();
      if h.autodiff {
        h.Ξ.pushBack(this);
        h.w <- h.w + logpdfLazy(x);
      } else {
        h.w <- h.w + logpdf(x);
      }
      if this.hasJoined() {
        this.getJoined().setSubordinate(true);
      }
      this.x <- x;
      pin();
    }
  }

  final function move(visitor:MoveVisitor) -> Value! {
    if this.hasUpdated() {
      return this.getUpdatedDistribution().move(visitor);
    } else if !flagPinned {
      visitCount <- visitCount + 1;
      if visitCount == 1 {
        visitor.visit(this);
      }
      if visitCount >= linkCount {
        assert visitCount == linkCount;
        visitCount <- 0;  // reset for next time
      }
    }
    assert x?;
    return x!;
  }

  final function args(visitor:ArgsVisitor) {
    if this.hasUpdated() {
      this.getUpdatedDistribution().args(visitor);
    } else if !flagPinned {
      visitCount <- visitCount + 1;
      if visitCount == 1 {
        visitor.visit(this);
      }
      if visitCount >= linkCount {
        assert visitCount == linkCount;
        visitCount <- 0;  // reset for next time
      }
    }
  }

  final function grad<Gradient>(g:Gradient, visitor:GradVisitor) {
    if this.hasUpdated() {
      this.getUpdatedDistribution().grad(g, visitor);
    } else if !flagPinned {
      visitCount <- visitCount + 1;
      if visitCount == 1 {
        /* (re-)start accumulation */
        this.g <- g;
      } else {
        /* continue accumulation */
        this.g <- this.g! + g;
      }
      if visitCount >= linkCount {
        assert visitCount == linkCount;
        visitCount <- 0;  // reset for next time
        visitor.visit(this);
        this.g <- nil;
      }
    }
  }

  final function reset() {
    if this.hasUpdated() {
      this.getUpdatedDistribution().reset();
    } else {
      assert visitCount == 0;
      g <- nil;
      offset <- 0;
      linkCount <- 0;
    }
  }

  final function relink(visitor:RelinkVisitor) {
    if this.hasUpdated() {
      this.getUpdatedDistribution().relink(visitor);
    } else if !flagPinned {
      assert visitCount == 0;
      linkCount <- linkCount + 1;
      if linkCount == 1 {
        visitor.visit(this);
      }
    }
  }

  final function pin() {
    if this.hasUpdated() {
      this.getUpdatedDistribution().pin();
    } else {
      g <- nil;
      offset <- 0;
      linkCount <- 0;
      visitCount <- 0;
      flagPinned <- true;
    }
  }

  override function fix() {
    flagPinned <- true;
  }

  final function isConstantVariate() -> Boolean {
    if this.hasUpdated() {
      return this.getUpdatedDistribution().isConstantVariate();
    } else {
      return flagPinned;
    }
  }

  final function hasValue() -> Boolean {
    if this.hasUpdated() {
      return this.getUpdatedDistribution().hasValue();
    } else {
      return x?;
    }
  }
}
