/**
 * Multivariate Gaussian distribution with linear transformation of
 * multivariate-normal-inverse-gamma prior.
 */
class MultivariateNormalInverseGammaMultivariateGaussianDistribution<
    Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7>(A:Arg1, ν:Arg2, Λ:Arg3, k:Arg4,
    γ:Arg5, c:Arg6, Ω:Arg7) < Distribution<Real[_]> {
  /**
   * Scale.
   */
  A:Arg1 <- A;

  /**
   * Precision times mean.
   */
  ν:Arg2 <- ν;

  /**
   * Precision.
   */
  Λ:Arg3 <- Λ;

  /**
   * Degrees of freedom.
   */
  k:Arg4 <- k;

  /**
   * Variance scale.
   */
  γ:Arg5 <- γ;

  /**
   * Offset.
   */
  c:Arg6 <- c;

  /**
   * Covariance scale.
   */
  Ω:Arg7 <- Ω;

  override function simulate() -> Real[_] {
    return value(simulate_multivariate_normal_inverse_gamma_multivariate_gaussian(
      A, ν, Λ, k, γ, c, Ω));
  }

  override function simulateLazy() -> Real[_] {
    return eval(simulate_multivariate_normal_inverse_gamma_multivariate_gaussian(
        A, ν, Λ, k, γ, c, Ω));
  }
  
  override function logpdf(x:Real[_]) -> Real! {
    return value(logpdf_multivariate_normal_inverse_gamma_multivariate_gaussian(
        x, A, ν, Λ, k, γ, c, Ω));
  }

  override function logpdfLazy(x:Real[_]) -> Real! {
    return eval(logpdf_multivariate_normal_inverse_gamma_multivariate_gaussian(
        x, A, ν, Λ, k, γ, c, Ω));
  }

  override function update(x:Real[_]) -> Delay? {
    return update_multivariate_normal_inverse_gamma_multivariate_gaussian(
        x, A, ν, Λ, k, γ, c, Ω);
  }

  override function hoist() -> Expression<Real> {
    return box(logpdf_multivariate_normal_inverse_gamma_multivariate_gaussian(
        random(), A, ν, Λ, k, γ, c, Ω));
  }

  override function updateLazy(x:Random<Real[_]>) -> Delay? {
    return update_multivariate_normal_inverse_gamma_multivariate_gaussian(
        x, A, ν, Λ, k, γ, c, Ω);
  }

  override function fix() {
    super.fix();
    constant(A);
    constant(ν);
    constant(Λ);
    constant(γ);
    constant(c);
    constant(Ω);
  }
}

function MultivariateNormalInverseGammaMultivariateGaussian<Arg1,
    Arg2,Arg3,Arg4,Arg5,Arg6,Arg7>(A:Arg1, μ:Arg2, Σ:Arg3, α:Arg4, β:Arg5,
    c:Arg6, Ω:Arg7) -> Distribution<Real[_]> {
  let L <- chol(Σ);
  let o <- trisolve(L, μ);
  let ν <- triinnersolve(L, o);
  let Λ <- cholinv(L);
  let k <- 2.0*α;
  let γ <- 2.0*β + dot(o);
  return make_multivariate_normal_inverse_gamma_multivariate_gaussian(
      A, ν, Λ, k, γ, c, Ω);
}
function make_multivariate_normal_inverse_gamma_multivariate_gaussian<
    Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7>(A:Arg1, ν:Arg2, Λ:Arg3, k:Arg4,
    γ:Arg5, c:Arg6, Ω:Arg7) -> {
  return peg_multivariate_normal_inverse_gamma_multivariate_gaussian(
      peg(A), peg(ν), peg(Λ), peg(k), peg(γ),
      peg(c), peg(Ω));
}
function peg_multivariate_normal_inverse_gamma_multivariate_gaussian<
    Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7>(A:Arg1, ν:Arg2, Λ:Arg3, k:Arg4,
    γ:Arg5, c:Arg6, Ω:Arg7) -> {
  return MultivariateNormalInverseGammaMultivariateGaussianDistribution<
      Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7>(A, ν, Λ, k, γ, c, Ω);
}

/**
 * Create multivariate Gaussian distribution.
 */
function MultivariateGaussian<Arg1,Arg2,Arg3>(μ:Add<Mul<Arg1,
    Random<Real[_]>>,Arg2>, Σ:Mul<Arg3,Random<Real>>) ->
    Distribution<Real[_]> {
  let A <- μ.l().l();
  let m <- μ.l().r();
  let c <- μ.r();
  let Ω <- Σ.l();
  let ω2 <- Σ.r();
  if ω2.isInverseGamma() && m.isMultivariateNormalInverseGamma() &&
      ω2.hasMarginalized() && ω2.getMarginalized().getUpdated() ==
      m.getDistribution().getUpdated() {
    let p_ω2 <- ω2.getDistribution();
    let p_m <- m.graft();
    let (ν, Λ, k, γ) <- p_m.getMultivariateNormalInverseGamma()!;
    let p <- make_multivariate_normal_inverse_gamma_multivariate_gaussian(A,
        ν, Λ, k, γ, c, Ω);
    p_ω2.setSecondOrder(true);
    p_m.setMarginalized(p);
    return p;
  } else if ω2.isInverseGamma() {
    let p_ω2 <- ω2.graft();
    let (α, β) <- p_ω2.getInverseGamma()!;
    let L <- chol(Ω);
    let o <- trisolve(L, μ);
    let ν <- triinnersolve(L, o);
    let Λ <- cholinv(L);
    let k <- 2.0*α;
    let γ <- 2.0*β + dot(o);
    let p <- make_multivariate_normal_inverse_gamma(ν, Λ, k, γ);
    p_ω2.setMarginalized(p);
    return p;
  } else if m.isMultivariateGaussian() {
    let p_m <- m.graft();
    let (m1, S) <- p_m.getMultivariateGaussian()!;
    let p <- make_multivariate_gaussian_multivariate_gaussian(A, m1, S, c, Σ);
    p_m.setMarginalized(p);
    return p;
  } else {
    return make_multivariate_gaussian(μ, Σ);
  }
}

/**
 * Create multivariate Gaussian distribution.
 */
function MultivariateGaussian<Arg1,Arg2>(μ:Mul<Arg1,Random<Real[_]>>,
    Σ:Mul<Arg2,Random<Real>>) -> Distribution<Real[_]> {
  return MultivariateGaussian(μ + 0.0, Σ);
}

/**
 * Create multivariate Gaussian distribution.
 */
function MultivariateGaussian<Arg>(μ:Random<Real[_]>,
    Σ:Mul<Arg,Random<Real>>) -> Distribution<Real[_]> {
  return MultivariateGaussian(1.0*μ + 0.0, Σ);
}

/*
 * Simulate multivariate-normal-inverse-gamma-multivariate-Gaussian
 * distribution.
 *
 * @param A Scale.
 * @param ν Prior mean.
 * @param Λ Prior covariance.
 * @param k Prior degrees of freedom of the inverse-gamma ($k = 2\alpha$).
 * @param γ Prior scale of the inverse-gamma.
 * @param c Offset.
 * @param Ω Covariance scale.
 *
 * @return the posterior hyperparameters `ν'`, `Λ'`, `k'` and `γ'`.
 */
function simulate_multivariate_normal_inverse_gamma_multivariate_gaussian<
    Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7>(A:Arg1, ν:Arg2, Λ:Arg3, k:Arg4,
    γ:Arg5, c:Arg6, Ω:Arg7) -> {
  let L <- chol(Λ);
  let o <- trisolve(L, ν);
  let μ <- triinnersolve(L, o);
  let β <- γ - dot(o);  // actually two times beta
  let m <- A*μ + c;
  let S <- β*(inner(trisolve(L, transpose(A))) + Ω);
  return simulate_multivariate_t(k, m, S);
}

/*
 * Observe multivariate-normal-inverse-gamma-multivariate-Gaussian
 * variate.
 *
 * @param x The variate.
 * @param A Scale.
 * @param ν Prior mean.
 * @param Λ Prior covariance.
 * @param k Prior degrees of freedom of the inverse-gamma ($k = 2\alpha$).
 * @param γ Prior scale of the inverse-gamma.
 * @param c Offset.
 * @param Ω Covariance scale.
 *
 * @return the posterior hyperparameters `ν'`, `Λ'`, `k'` and `γ'`.
 */
function logpdf_multivariate_normal_inverse_gamma_multivariate_gaussian<
    Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>(x:Arg1, A:Arg2, ν:Arg3, Λ:Arg4,
    k:Arg5, γ:Arg6, c:Arg7, Ω:Arg8) -> {
  let L <- chol(Λ);
  let o <- trisolve(L, ν);
  let μ <- triinnersolve(L, o);
  let β <- γ - dot(o);  // actually two times beta
  let m <- A*μ + c;
  let S <- β*(inner(trisolve(L, transpose(A))) + Ω);
  return logpdf_multivariate_t(x, k, m, S);
}

/*
 * Update the parameters of a normal inverse-gamma distribution with a
 * linear transformation and multivariate Gaussian likelihood.
 *
 * @param x The variate.
 * @param A Scale.
 * @param ν Prior mean.
 * @param Λ Prior covariance.
 * @param k Prior degrees of freedom of the inverse-gamma ($k = 2\alpha$).
 * @param γ Prior scale of the inverse-gamma.
 * @param c Offset.
 * @param Ω Covariance scale.
 *
 * @return the posterior hyperparameters `ν'`, `Λ'`, `k'` and `γ'`.
 */
function update_multivariate_normal_inverse_gamma_multivariate_gaussian<
    Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>(x:Arg1, A:Arg2,
    ν:Arg3, Λ:Arg4, k:Arg5, γ:Arg6, c:Arg7, Ω:Arg8) -> {
  let n <- length(x);
  let L <- chol(Ω);
  let o <- trisolve(L, x - c);
  let Λ' <- Λ + inner(trisolve(L, A));
  let ν' <- ν + transpose(A)*triinnersolve(L, o);
  let k' <- k + n;
  let γ' <- γ + dot(o);
  return make_multivariate_normal_inverse_gamma(ν', Λ', k', γ');
}
