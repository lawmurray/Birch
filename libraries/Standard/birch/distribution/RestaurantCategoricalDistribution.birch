/**
 * Restaurant-categorical distribution.
 */
final class RestaurantCategoricalDistribution<Arg1,Arg2,Arg3>(α:Arg1, θ:Arg2,
    n:Arg3) < Distribution<Integer> {
  /**
   * Concentration.
   */
  α:Arg1 <- α;
  
  /**
   * Strength.
   */
  θ:Arg2 <- θ;

  /**
   * Number of samples drawn in each component.
   */
  n:Arg3 <- n;

  override function simulate() -> Integer! {
    return simulate_restaurant_categorical(value(α), value(θ), value(n));
  }

  override function simulateLazy() -> Integer! {
    return simulate_restaurant_categorical(eval(α), eval(θ), eval(n));
  }

  override function logpdf(x:Integer!) -> Real! {
    return value(logpdf_restaurant_categorical(x, α, θ, n));
  }

  override function logpdfLazy(x:Integer!) -> Real! {
    return eval(logpdf_restaurant_categorical(x, α, θ, n));
  }

  override function update(x:Integer!) -> Delay? {
    return update_restaurant_categorical(x, α, θ, n);
  }

  override function updateLazy(x:Random<Integer>) -> Delay? {
    return update_restaurant_categorical(x, α, θ, n);
  }

  override function hoist() -> Expression<Real> {
    return box(logpdf_restaurant_categorical(random(), α, θ, n));
  }

  override function fix() {
    super.fix();
    constant(α);
    constant(θ);
    constant(n);
  }
}

function RestaurantCategorical<Arg1,Arg2,Arg3>(α:Arg1, θ:Arg2, n:Arg3) ->
    Distribution<Integer> {
  return make_restaurant_categorical(α, θ, n);
}
function make_restaurant_categorical<Arg1,Arg2,Arg3>(α:Arg1, θ:Arg2,
    n:Arg3) -> {
  return peg_restaurant_categorical(peg(α), peg(θ),
      peg(n));
}
function peg_restaurant_categorical<Arg1,Arg2,Arg3>(α:Arg1, θ:Arg2,
    n:Arg3) -> {
  return RestaurantCategoricalDistribution<Arg1,Arg2,Arg3>(α, θ, n);
}

/*
 * Simulate a categorical distribution with Chinese restaurant process
 * prior.
 *
 * @param α Concentration.
 * @param θ Discount.
 * @param n Vector of number of draws of each element.
 */
function simulate_restaurant_categorical(α:Real, θ:Real, n:Integer[_]) ->
    Integer {
  let k <- 0;
  let α1 <- α;
  let θ1 <- θ;
  let K <- count(n)!;
  let N <- sum(n)!;
  if N == 0 {
    /* first component */
    k <- 1;
  } else {
    let u <- simulate_uniform(0.0, N + θ1);
    let U <- K*α1 + θ1;
    if u < U {
      /* new component */
      k <- K + 1;
    } else {
      /* existing component */
      while k < K && u > U {
        k <- k + 1;
        U <- U + n[k] - α1;
      }
    }
  }
  return k;
}

/*
 * Observe a categorical variate with Chinese restaurant process
 * prior.
 *
 * @param x The variate.
 * @param α Concentration.
 * @param θ Discount.
 * @param n Vector of number of draws of each element.
 */
function logpdf_restaurant_categorical<Arg1,Arg2,Arg3,Arg4>(x:Arg1, α:Arg2,
    θ:Arg3, n:Arg4) -> {
  return log(where(element(n, x) == 0, count(n)*α + θ,
      element(n, x) - α)) - log(sum(n) + θ);
}

/*
 * Update the parameters of a Chinese restaurant process with a categorical
 * likelihood.
 *
 * @param x The variate.
 * @param α Concentration.
 * @param θ Discount.
 * @param n Vector of number of draws of each element.
 */
function update_restaurant_categorical<Arg1,Arg2,Arg3,Arg4>(x:Arg1, α:Arg2,
    θ:Arg3, n:Arg4) -> {
  let n' <- n + single(1, x, length(n));
  return make_restaurant(α, θ, n');
}
