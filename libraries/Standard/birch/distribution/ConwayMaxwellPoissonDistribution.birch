/**
 * Conway-Maxwell-Poisson distribution.
 *
 * @param μ Mode.
 * @param ν Dispersion.
 * @param n Truncation point.
 *
 * The distribution is always truncated on $[0,n]$ because of an intractable
 * normalizing constant that can only be expressed as an infinite series on
 * the support of the non-truncated distribution, $[0,\infty)$. The larger
 * $n$, the closer the approximation to the non-truncated distribution---if
 * that is desired---but the more expensive operations: most are $O(n)$.
 */
class ConwayMaxwellPoissonDistribution<Arg1,Arg2,Arg3>(μ:Arg1, ν:Arg2,
    n:Arg3) < Distribution<Integer> {
  /**
   * Mode.
   */
  μ:Arg1 <- μ;

  /**
   * Dispersion.
   */
  ν:Arg2 <- ν;

  /**
   * Truncation point.
   */
  n:Arg3 <- n;

  override function simulate() -> Integer! {
    return simulate_conway_maxwell_poisson(value(μ), value(ν), value(n));
  }

  override function simulateLazy() -> Integer! {
    return simulate_conway_maxwell_poisson(eval(μ), eval(ν), eval(n));
  }

  override function logpdf(x:Integer!) -> Real! {
    return value(logpdf_conway_maxwell_poisson(x, μ, ν, n));
  }

  override function logpdfLazy(x:Integer!) -> Real! {
    return eval(logpdf_conway_maxwell_poisson(x, μ, ν, n));
  }

  override function cdf(x:Integer!) -> Real!? {
    return cdf_conway_maxwell_poisson(x, value(μ), value(ν), value(n));
  }

  override function hoist() -> Expression<Real> {
    return box(logpdf_conway_maxwell_poisson(random(), μ, ν, n));
  }

  override function lower() -> Integer!? {
    return 0;
  }

  override function upper() -> Integer!? {
    return value(n);
  }

  override function fix() {
    super.fix();
    constant(μ);
    constant(ν);
    constant(n);
  }

  override function isBoundedDiscrete() -> Boolean {
    return !x?;
  }

  override function getBoundedDiscrete() -> (Expression<Real[_]>, Integer!)? {
    assert isBoundedDiscrete();
    let p <- exp(logpdf_conway_maxwell_poisson(iota(0, n + 1), μ, ν, n));
    return (box(p/sum(p)), 0);
    // ^ numerical errors can accumulate, so renormalize
  }

  override function write(buffer:Buffer) {
    buffer.set("class", "ConwayMaxwellPoisson");
    buffer.set("μ", value(μ));
    buffer.set("ν", value(ν));
    buffer.set("n", value(n));
  }
}

/**
 * Create Conway-Maxwell-Poisson distribution.
 */
function ConwayMaxwellPoisson<Arg1,Arg2,Arg3>(μ:Arg1, ν:Arg2, n:Arg3) ->
    Distribution<Integer> {
  return make_conway_maxwell_poisson(μ, ν, n);
}
function make_conway_maxwell_poisson<Arg1,Arg2,Arg3>(μ:Arg1, ν:Arg2,
    n:Arg3) -> {
  return peg_conway_maxwell_poisson(peg(μ), peg(ν), peg(n));
}
function peg_conway_maxwell_poisson<Arg1,Arg2,Arg3>(μ:Arg1, ν:Arg2,
    n:Arg3) -> {
  return ConwayMaxwellPoissonDistribution<Arg1,Arg2,Arg3>(μ, ν, n);
}

/*
 * Simulate a Conway-Maxwell-Poisson distribution.
 *
 * @param μ Mode.
 * @param ν Dispersion.
 * @param n Truncation point.
 */
function simulate_conway_maxwell_poisson<Arg1,Arg2,Arg3>(μ:Arg1, ν:Arg2,
    n:Arg3) -> {
  let p <- exp(logpdf_conway_maxwell_poisson(iota(0, n + 1), μ, ν, n));
  return simulate_categorical(p, 1.0) - 1;
}

/*
 * Observe a Conway-Maxwell-Poisson variate.
 *
 * @param x The variate.
 * @param μ Mode.
 * @param ν Dispersion.
 * @param n Truncation point.
 *
 * @return the log probability mass.
 */
function logpdf_conway_maxwell_poisson<Arg1,Arg2,Arg3,Arg4>(x:Arg1, μ:Arg2,
    ν:Arg3, n:Arg4) -> {
  return where(0 <= x && x <= n, x*ν*log(μ) - ν*lfact(x) -
      logz_conway_maxwell_poisson(μ, ν, n), -inf);
}

/*
 * CDF of a Conway-Maxwell-Poisson variate.
 *
 * @param x The variate.
 * @param μ Mode.
 * @param ν Dispersion.
 * @param n Truncation point.
 *
 * @return the cumulative probability.
 */
function cdf_conway_maxwell_poisson<Arg1,Arg2,Arg3,Arg4>(x:Arg1, μ:Arg2,
    ν:Arg3, n:Arg4) -> {
  let p <- exp(logpdf_conway_maxwell_poisson(iota(0, n + 1), μ, ν, n));
  return cdf_categorical(x + 1, p, 1.0);
}
