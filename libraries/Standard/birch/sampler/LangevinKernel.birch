/**
 * Langevin Markov kernel, with Metropolis adjustment.
 *
 * ```mermaid
 * classDiagram
 *    Kernel <|-- LangevinKernel
 *    link Kernel "../Kernel/"
 *    link LangevinKernel "../LangevinKernel/"
 * ```
 */
class LangevinKernel < Kernel {
  override function move(m:Model) -> Real {
    let naccepts <- 0;
    if nmoves > 0 {
      let π <- m.hoist();
      if π? {
        π!.trace();
        let p <- π!.eval();
        let x <- π!.args();
        let g <- π!.grad();
        let μ <- eval(x + g*scale);  // mean of proposal from initial state
        let accept <- true;  // was most recent proposal accepted?
        let n <- length(x);
        for k in 1..nmoves {
          /* proposed state */
          let x' <- eval(μ + standard_gaussian(n)*sqrt(2.0*scale));
          let p' <- π!.move(x');
          let g' <- π!.grad();
          let μ' <- eval(x' + g'*scale);

          /* proposal correction */
          let q <- (pow(x - μ', 2.0) - pow(x' - μ, 2.0))/scale;
          let r <- -0.25*sum(where(isfinite(q), q, 0.0));

          /* accept/reject */
          accept <- (log(simulate_uniform(0.0, 1.0)) <= p' - p + r)!;
          if accept {
            naccepts <- naccepts + 1;
            x <- x';
            p <- p';
            g <- g';
            μ <- μ';
          }
          if !accept {
            π!.move(x);  // last proposal was rejected, restore correct arguments
          }
        }
      }

      /* clean up and apply lag for next time */
      m.fix(nlags);
    }
    return cast<Real>(naccepts)/nmoves;
  }
}
