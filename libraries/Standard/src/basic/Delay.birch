/**
 * Base class for objects supporting delayed sampling.
 *
 * ```mermaid
 * classDiagram
 *    Delay <|-- Expression
 *    Delay <|-- Distribution
 *    Expression <|-- Random
 *
 *    link Delay "../Delay/"
 *    link Expression "../Expression/"
 *    link Random "../Random/"
 * ```
 *
 * Classes derived from Delay support delayed sampling. Ostensibly this
 * includes all Distribution and Expression classes, although among Expression
 * classes only Random actually implements the interface.
 *
 * ### Design & Implementation
 *
 * The $M$-path for delayed sampling is kept as a singly-linked list of Delay
 * objects directed from root to leaf along the $M$-path. While all objects in
 * the path are ostensibly of abstract type Delay, they are alternately of
 * concrete type Random and Distribution (`R*` denotes a Random object, `D*` a
 * Distribution object):
 *
 * ```mermaid
 * graph LR
 *    R1((R1)) --> D2((D2)) --> R2((R2)) --> D3((D3))
 * ```
 *
 * The root is necessarily of type Random, but the leaf may be of either type
 * Distribution (as above) or, if a Random has been associated with that
 * Distribution, of type Random. In the latter case the final node is
 * doubly-linked:
 *
 * ```mermaid
 * graph LR
 *    R1((R1)) --> D2((D2)) --> R2((R2)) --> D3((D3)) --> R3((R3))
 *    R3((R3)) .-> D3
 * ```
 *
 * While, if the leaf node is of type Random, it has a backward link to its
 * associated Distribution, note that all other nodes of type Random only have
 * a forward link to the distribution associated with their next node on the
 * $M$-path.
 *
 * User code maintains external references to the Random objects, but
 * typically not the Distribution objects. Delayed sampling operations are
 * triggered by the use of these references.
 *
 * @note
 *     One advantage of this arrangement is that variable elimination
 *     naturally occurs as a result of garbage collection. Once no references
 *     remain to a Random that is the root of an $M$-path it is collected,
 *     usually along with the next Distribution in the list. Not only has it
 *     then been *marginalized out* in establishing the $M$-path, but it has
 *     now been *eliminated* as the program has discarded it without it ever
 *     being sampled.
 *
 * Events on the list are triggered by user operations on the Random objects,
 * to which the user code maintains references.
 *
 * The *graft* operation occurs when the leaf node is a Random, and that
 * Random enters the construction of a new Distribution object in a form that
 * allows it to be marginalized out. The Distribution is appened to the list
 * and the existing backward link remove:
 *
 * ```mermaid
 * graph LR
 *    R1((R1)) --> D2((D2)) --> R2((R2)) --> D3((D3)) --> R3((R3)) --> D4((D4))
 * ```
 *
 * If a Random is subsequently associated with the Distribution it is added as
 * before:
 *
 * ```mermaid
 * graph LR
 *    R1((R1)) --> D2((D2)) --> R2((R2)) --> D3((D3)) --> R3((R3)) --> D4((D4)) --> R4((R4))
 *    R4((R4)) .-> D4
 * ```
 *
 * If a Random leaf node must be *realized* it simply simulates a value from
 * its associated distribution and removes its backward link:
 *
 * ```mermaid
 * graph LR
 *    R1((R1)) --> D2((D2)) --> R2((R2)) --> D3((D3)) --> R3((R3)) --> D4((D4)) --> R4
 * ```
 *
 *
 * ```mermaid
 * graph LR
 *    R1((R1)) --> D2((D2)) --> R2((R2)) --> D3((D3)) --> R3((R3)) --> D4((D4'))
 * ```
 */
abstract class Delay {
  /**
   * Marginalized distribution.
   */
  marginalized:Delay?;

  /**
   * Updated distribution.
   */
  updated:Delay?;

  /**
   * Joined distribution.
   */
  joined:Delay?;

  /**
   * Is this a subordinate in a joint distribution?
   */
  subordinate:Boolean <- false;

  /**
   * Does this expect a second-order update?
   */
  second:Boolean <- false;

  /**
   * Is there a marginalized distribution?
   */
  final function hasMarginalized() -> Boolean {
    return marginalized?;
  }

  /**
   * Get the marginalized distribution.
   */
  final function getMarginalized() -> Delay {
    assert marginalized?;
    return marginalized!;
  }

  /**
   * Set the marginalized distribution.
   */
  final function setMarginalized(marginalized:Delay?) {
    this.marginalized <- marginalized;
  }

  /**
   * Is there an updated distribution?
   */
  final function hasUpdated() -> Boolean {
    return updated?;
  }

  /**
   * Get the updated distribution. If there is no updated distribution,
   * returns this.
   */
  final function getUpdated() -> Delay {
    if updated? {
      return updated!;
    } else {
      return this;
    }
  }

  /**
   * Set the updated distribution.
   */
  final function setUpdated(updated:Delay?) {
    this.updated <- updated;
  }

  /**
   * Is there a joined distribution?
   */
  final function hasJoined() -> Boolean {
    return joined?;
  }

  /**
   * Get the joined distribution.
   */
  final function getJoined() -> Delay {
    assert joined?;
    return joined!;
  }

  /**
   * Set the joined distribution.
   */
  final function setJoined(joined:Delay?) {
    this.joined <- joined;
  }

  /**
   * Is this a subordinate in a joint distribution?
   */
  final function isSubordinate() -> Boolean {
    return subordinate;
  }

  /**
   * Set the subordinate flag.
   */
  final function setSubordinate(subordinate:Boolean) {
    this.subordinate <- subordinate;
  }

  /**
   * Does this expect a second-order update?
   *
   * Usually a joint distribution of random variables $x$, $y$, and $z$ that
   * are adjacent on the $M$-path have a joint distribution that can be
   * decomposed as
   * $$p(\mathrm{d}x, \mathrm{d}y, \mathrm{d}z) = p(\mathrm{d}x)
   * p(\mathrm{d}y | x) p(\mathrm{d}z | y).$$
   * When isSecondOrder() is true for $x$, the decomposition is instead
   * $$p(\mathrm{d}x, \mathrm{d}y, \mathrm{d}z) = p(\mathrm{d}x)
   * p(\mathrm{d}y | x) p(\mathrm{d}z | x, y).$$
   * The conditional update on $x$ would usually encode $p(\mathrm{d}x | y)$,
   * but instead encodes $p(\mathrm{d}x | y, z)$ in this case.
   *
   * Examples of such updates include sums of discrete random variables, and
   * conjugacies involving normal-inverse-gamma and (multivariate or matrix)
   * normal-inverse-Wishart distributions.
   */
  final function isSecondOrder() -> Boolean {
    return second;
  }

  /**
   * Set the second-order flag.
   */
  final function setSecondOrder(second:Boolean) {
    this.second <- second;
  }

  /**
   * Prepare the node for stateful operations
   *
   * @return Updated distribution.
   */
  function graft() -> Delay {
    let p <- this;
    let p' <- this.getUpdated();
    if p'.hasMarginalized() {
      let q <- p'.getMarginalized();
      p'.setMarginalized(nil);
      let q' <- q.graft();
      q'.realize();

      let h <- get_handler();
      if h.autojoin && q.supportsJoin() {
        /* in this case, preserve the current updated distribution for this,
         * but join the marginalized distribution to it */
        p'.setJoined(q');
      } else if p.isSecondOrder() {
        /* in this case, q' is a joint distribution over the random variable
         * associated with this distribution and the parent distribution,
         * condition it to update the parent distribution */  
        p.setUpdated(q'.condition());
      } else {
        /* in this case, q' is just over the random variable associated with
         * this distribution, condition the original distribution to update
         * the parent distribution */
        p.setUpdated(q.condition());
      }
    }
    return p.getUpdated();
  }

  /**
   * Realize a value for this node.
   */
  function realize() {
    //
  }

  /**
   * Condition the parent node on the $M$-path.
   */
  function condition() -> Delay? {
    return nil;
  }

  /**
   * Render the node constant.
   */
  function constant() {
    //
  }

  /**
   * Construct a lazy expression for the log-pdf of this node.
   */
  function hoist() -> Expression<Real> {
    assert false;
    return box(0.0);
  }

  /**
   * Are join operations supported?
   */
  function supportsJoin() -> Boolean {
    return false;
  }

  function isGaussian() -> Boolean {
    return false;
  }

  function getGaussian() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isBeta() -> Boolean {
    return false;
  }

  function getBeta() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isGamma() -> Boolean {
    return false;
  }

  function getGamma() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isInverseGamma() -> Boolean {
    return false;
  } 

  function getInverseGamma() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isInverseWishart() -> Boolean {
    return false;
  } 

  function getInverseWishart() -> (Expression<Real[_,_]>, Expression<Real>)? {
    return nil;
  } 

  function isNormalInverseGamma() -> Boolean {
    return false;
  }

  function getNormalInverseGamma() -> (Expression<Real>, Expression<Real>,
      Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isDirichlet() -> Boolean {
    return false;
  }

  function getDirichlet() -> Expression<Real[_]>? {
    return nil;
  }

  function isRestaurant() -> Boolean {
    return false;
  }

  function getRestaurant() -> (Expression<Real>, Expression<Real>,
      Expression<Integer[_]>)? {
    return nil;
  }

  function isMultivariateGaussian() -> Boolean {
    return false;
  }

  function getMultivariateGaussian() -> (Expression<Real[_]>,
      Expression<Real[_,_]>)? {
    return nil;
  }

  function isMultivariateNormalInverseGamma() -> Boolean {
    return false;
  }

  function getMultivariateNormalInverseGamma() -> (Expression<Real[_]>,
      Expression<Real[_,_]>, Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isMultivariateNormalInverseWishart() -> Boolean {
    return false;
  }

  function getMultivariateNormalInverseWishart() -> (Expression<Real[_]>,
      Expression<Real>, Expression<Real[_,_]>, Expression<Real>)? {
    return nil;
  }

  function isMatrixGaussian() -> Boolean {
    return false;
  }

  function getMatrixGaussian() -> (Expression<Real[_,_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>)? {
    return nil;
  }

  function isMatrixNormalInverseWishart() -> Boolean {
    return false;
  }

  function getMatrixNormalInverseWishart() -> (Expression<Real[_,_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>, Expression<Real>)? {
    return nil;
  }

  function isBoundedDiscrete() -> Boolean {
    return false;
  }

  function getBoundedDiscrete() -> (Expression<Real[_]>, Integer!)? {
    return nil;
  }

  function getMultivariateNormalInverseGammaGaussian() ->
      (Expression<Real[_]>, Expression<Real[_]>, Expression<Real[_,_]>,
      Expression<Real>, Expression<Real>, Expression<Real>,
      Expression<Real>)? {
    return nil;
  }

  function joinMultivariateNormalInverseGammaGaussian() ->
      (Expression<Real[_]>, Expression<Real[_,_]>, Expression<Real[_]>,
      Expression<Real[_,_]>, Expression<Real>, Expression<Real>,
      Expression<Real[_]>, Expression<Real[_]>)? {
    return nil;
  }

  function getMatrixNormalInverseWishartMultivariateGaussian(
      x:Random<Real[_]>) -> (Expression<Real[_]>, Expression<Real[_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>, Expression<Real[_,_]>,
      Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function joinMatrixNormalInverseWishartMultivariateGaussian() ->
      (Expression<Real[_,_]>, Expression<Real[_,_]>, Expression<Real[_,_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>, Expression<Real>,
      Expression<Real[_,_]>)? {
    return nil;
  }
}
