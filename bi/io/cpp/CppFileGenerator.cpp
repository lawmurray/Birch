/**
 * @file
 */
#include "bi/io/cpp/CppFileGenerator.hpp"

#include "bi/io/cpp/CppTypeGenerator.hpp"
#include "bi/io/cpp/CppParameterGenerator.hpp"
#include "bi/io/cpp/CppCoroutineGenerator.hpp"
#include "bi/expression/all.hpp"
#include "bi/exception/all.hpp"
#include "bi/primitive/encode.hpp"
#include "bi/visitor/Gatherer.hpp"

#include "boost/filesystem.hpp"
#include "boost/algorithm/string.hpp"

#include <sstream>
#include <iomanip>
#include <typeinfo>

bi::CppFileGenerator::CppFileGenerator(std::ostream& base, const int level,
    const bool header) :
    CppBaseGenerator(base, level, header) {
  //
}

void bi::CppFileGenerator::visit(const File* o) {
  line("/**");
  line(" * @file");
  line(" *");
  line(" * Automatically generated by Birch.");
  line(" */");

  if (header) {
    /* include guard */
    line("#pragma once\n");

    /* standard headers */
    line("#include \"bi/bi.hpp\"");
  } else {
    /* include main header file */
    boost::filesystem::path file(o->path);
    file.replace_extension(".hpp");
    line("#include \"" << file.filename().string() << "\"\n");

    line("");
  }

  /* main code */
  *this << o->root;
}

void bi::CppFileGenerator::visit(const Import* o) {
  if (header) {
    line("#include \"" << hpp(o->path->file()) << "\"");
  }
}

void bi::CppFileGenerator::visit(const GlobalVariable* o) {
  if (header) {
    line("namespace bi {");
    line("extern " << o->type << ' ' << o->name << ';');
    line("}\n");
  } else {
    start(o->type << " bi::" << o->name);
  }
}

void bi::CppFileGenerator::visit(const Function* o) {
  if (!o->braces->isEmpty()) {
    if (header) {
      line("namespace bi {");
      in();
      line("namespace func {");
      out();
    }

    /* return type */
    ++inReturn;
    start(o->returnType << ' ');
    --inReturn;

    /* name */
    if (!header) {
      middle("bi::func::");
    }
    middle(internalise(o->name->str()));

    /* parameters */
    CppParameterGenerator auxParameter(base, level, header);
    auxParameter << o;

    if (header) {
      finish(';');
    } else {
      finish(" {");
      in();

      /* body */
      CppBaseGenerator aux(base, level, false);
      aux << o->braces;

      out();
      finish("}\n");
    }
    if (header) {
      in();
      line("}");
      out();
      line("}\n");
    }
  }
}

void bi::CppFileGenerator::visit(const Coroutine* o) {
  CppCoroutineGenerator auxCoroutine(base, level, header);
  auxCoroutine << o;
}

void bi::CppFileGenerator::visit(const Program* o) {
  if (header) {
    line("namespace bi {");
    in();
    line("namespace program {");
    out();
    line("extern \"C\" void " << o->name << "(int argc_, char** argv_);");
    in();
    line("}");
    out();
    line("}\n");
  } else {
    line("void bi::program::" << o->name << "(int argc_, char** argv_) {");
    in();
    if (o->parens->tupleSize() > 0) {
      /* option variables */
      for (auto iter = o->parens->begin(); iter != o->parens->end(); ++iter) {
        line(*iter << ';');
      }
      line("");

      /* option flags */
      line("enum {");
      in();
      for (auto iter = o->parens->begin(); iter != o->parens->end(); ++iter) {
        std::string flag =
            dynamic_cast<const Parameter*>(*iter)->name->str() + "_ARG_";
        boost::to_upper(flag);
        start(flag);
        if (iter == o->parens->begin()) {
          middle(" = 256");
        }
        finish(',');
      }
      out();
      line("};");

      /* long options */
      line("int c_, option_index_;");
      line("option long_options_[] = {");
      in();
      for (auto iter = o->parens->begin(); iter != o->parens->end(); ++iter) {
        const std::string& name =
            dynamic_cast<const Parameter*>(*iter)->name->str();
        //if (name.length() > 1) {
        std::string flag = name + "_ARG_";
        boost::to_upper(flag);
        std::string option = name;
        boost::replace_all(option, "_", "-");

        line(
            "{\"" << option << "\", required_argument, 0, " << flag << " },");
        //}
      }
      line("{0, 0, 0, 0}");
      out();
      line("};");

      /* short options */
      start("const char* short_options_ = \"");
      //for (auto iter = o->parens->begin(); iter != o->parens->end(); ++iter) {
      //  const std::string& name = dynamic_cast<const Parameter*>(*iter)->name->str();
      //  if (name.length() == 1) {
      //    middle(name << ':');
      //  }
      //}
      finish("\";");

      /* read in options with getopt_long */
      line("::opterr = 0; // handle error reporting ourselves");
      line(
          "c_ = getopt_long_only(argc_, argv_, short_options_, long_options_, &option_index_);");
      line("while (c_ != -1) {");
      in();
      line("switch (c_) {");
      in();

      for (auto iter = o->parens->begin(); iter != o->parens->end(); ++iter) {
        const std::string& name =
            dynamic_cast<const Parameter*>(*iter)->name->str();
        std::string flag = name + "_ARG_";
        boost::to_upper(flag);

        start("case ");
        //if (name.length() > 1) {
        middle(flag);
        //} else {
        //  middle('\'' << name << '\'');
        //}
        finish(':');
        in();
        Type* type = (*iter)->type->strip();
        const TypeReference* ref = dynamic_cast<const TypeReference*>(type);
        if (ref && *ref->name == "String") {
          line(name << " = ::optarg;");
        } else {
          line("left_(" << name << ", ::optarg);");
        }
        line("break;");
        out();
      }
      //line("default:");
      //in();
      //line("throw UnknownOptionException(argv[optind - 1]);");
      //line("break;");
      //out();
      out();
      line('}');
      line(
          "c_ = getopt_long_only(argc_, argv_, short_options_, long_options_, &option_index_);");
      out();
      line("}\n");
    }

    /* body of program */
    if (!o->braces->isEmpty()) {
      CppBaseGenerator aux(base, level, header);
      aux << o->braces;
    }

    out();
    line("}\n");
  }
}

void bi::CppFileGenerator::visit(const BinaryOperator* o) {
  if (!o->braces->isEmpty()) {
    if (header) {
      line("namespace bi {");
    }

    /* return type */
    ++inReturn;
    start(o->returnType << ' ');
    --inReturn;

    /* name */
    if (!header) {
      middle("bi::");
    }
    if (isTranslatable(o->name->str())) {
      middle("operator" << o->name);
    } else {
      middle(internalise(o->name->str()));
    }
    middle('(' << o->left << ", " << o->right << ')');
    if (header) {
      finish(';');
    } else {
      finish(" {");
      in();

      /* body */
      CppBaseGenerator aux(base, level, false);
      aux << o->braces;

      out();
      finish("}\n");
    }
    if (header) {
      line("}\n");
    }
  }
}

void bi::CppFileGenerator::visit(const UnaryOperator* o) {
  if (!o->braces->isEmpty()) {
    if (header) {
      line("namespace bi {");
    }

    /* return type */
    ++inReturn;
    start(o->returnType << ' ');
    --inReturn;

    /* name */
    if (!header) {
      middle("bi::");
    }
    if (isTranslatable(o->name->str())) {
      middle("operator" << o->name);
    } else {
      middle(internalise(o->name->str()));
    }
    middle('(' << o->single << ')');
    if (header) {
      finish(';');
    } else {
      finish(" {");
      in();

      /* body */
      CppBaseGenerator aux(base, level, false);
      aux << o->braces;

      out();
      finish("}\n");
    }
    if (header) {
      line("}\n");
    }
  }
}

void bi::CppFileGenerator::visit(const TypeParameter* o) {
  if (o->isAlias()) {
    if (header) {
      line("namespace bi {");
      in();
      line("namespace type {");
      out();
      line("using " << o->name << " = " << o->base << ';');
      in();
      line("}");
      out();
      line("}\n");
    }
  } else if (!o->isBuiltin()) {
    if (header) {
      line("namespace bi {");
      in();
      line("namespace type {");
      out();
    }
    CppTypeGenerator auxType(base, level, header);
    auxType << o;
    if (header) {
      in();
      line("}");
      out();
      line("}\n");
    }
  }
}

std::string bi::CppFileGenerator::hpp(const std::string& path) {
  boost::filesystem::path file = path;
  file.replace_extension(".hpp");
  return file.string();
}
