%code requires {
  #include "bi/lexer.hpp"
  #include "bi/build/Compiler.hpp"

  extern bi::Compiler* compiler;
  extern char *yytext;
}

%code {
  #include "bi/expression/all.hpp"
  #include "bi/statement/all.hpp"
  #include "bi/type/all.hpp"

  #include <sstream>

  std::stringstream raw;
  
  void setloc(bi::Located* o, YYLTYPE& loc) {
    o->loc->file = compiler->file;
    o->loc->firstLine = loc.first_line;
    o->loc->lastLine = loc.last_line;
    o->loc->firstCol = loc.first_column;
    o->loc->lastCol = loc.last_column;
  }

  bi::Location* make_loc(YYLTYPE& loc) {
    return new bi::Location(compiler->file, loc.first_line, loc.last_line,
        loc.first_column, loc.last_column);
  }
}

%union {
  bool valBool;
  int32_t valInt;
  double valReal;
  const char* valString;

  bi::Name* valName;
  bi::Path* valPath;
  bi::Expression* valExpression;
  bi::Type* valType;
  bi::Statement* valStatement;
}

%token <valString> IMPORT PROGRAM CLASS TYPE FUNCTION COROUTINE OPERATOR
%token <valString> IF ELSE FOR IN WHILE ASSERT RETURN YIELD CPP HPP THIS SUPER
%token <valString> FUNCTION_UPPER
%token <valString> DOUBLE_BRACE_OPEN DOUBLE_BRACE_CLOSE RAW NAME
%token <valBool> BOOL_LITERAL
%token <valInt> INT_LITERAL
%token <valReal> REAL_LITERAL
%token <valString> STRING_LITERAL
%token <valString> LEFT_OP RIGHT_OP LEFT_TILDE_OP RIGHT_TILDE_OP
%token <valString> AND_OP OR_OP LE_OP GE_OP EQ_OP NE_OP RANGE_OP

%type <valName> name binary_operator unary_operator assignment_operator
%type <valPath> path

%type <valExpression> prefix_operator
%type <valExpression> multiplicative_operator additive_operator relational_operator
%type <valExpression> equality_operator logical_and_operator logical_or_operator
%type <valExpression> observe_operator 
%type <valExpression> bool_literal int_literal real_literal string_literal
%type <valExpression> literal identifier
%type <valExpression> this_expression super_expression
%type <valExpression> parens_expression function_expression
%type <valExpression> member_expression primary_expression
%type <valExpression> brackets_expression index_expression index_list
%type <valExpression> postfix_expression prefix_expression
%type <valExpression> multiplicative_expression additive_expression
%type <valExpression> relational_expression equality_expression
%type <valExpression> logical_and_expression logical_or_expression
%type <valExpression> observe_expression expression_list expression
%type <valExpression> parameter parameter_list parameters
%type <valExpression> option option_list options
%type <valExpression> member_parameter member_parameter_list member_parameters
%type <valExpression> optional_member_parameters
%type <valExpression> arguments optional_arguments
%type <valExpression> size_list size value optional_value

%type <valStatement> global_variable_declaration local_variable_declaration
%type <valStatement> function_declaration coroutine_declaration program_declaration
%type <valStatement> member_variable_declaration member_function_declaration
%type <valStatement> member_coroutine_declaration
%type <valStatement> binary_operator_declaration unary_operator_declaration
%type <valStatement> conversion_operator_declaration assignment_operator_declaration
%type <valStatement> class_declaration alias_type_declaration basic_type_declaration
%type <valStatement> import cpp hpp assignment expression_statement if for
%type <valStatement> while assertion return yield
%type <valStatement> statement statements optional_statements
%type <valStatement> class_statement class_statements optional_class_statements
%type <valStatement> file_statement file_statements optional_file_statements
%type <valStatement> braces optional_braces
%type <valStatement> class_braces optional_class_braces

%type <valType> identifier_type primary_type parens_type function_type
%type <valType> postfix_type list_type type
%type <valType> type_parameter_list type_parameters
%type <valType> result optional_result

%locations

%start file
%%


/***************************************************************************
 * Names and paths                                                         *
 ***************************************************************************/

name
    : NAME  { $$ = new bi::Name($1); }
    ;

path
    : name           { $$ = new bi::Path($1, nullptr, make_loc(@$)); }
    | name '.' path  { $$ = new bi::Path($1, $3, make_loc(@$)); }
    ;


/***************************************************************************
 * Expressions                                                             *
 ***************************************************************************/

bool_literal
    : BOOL_LITERAL  { $$ = new bi::Literal<bool>($1, yytext, new bi::BasicType(new bi::Name("Boolean")), make_loc(@$)); }
    ;

int_literal
    : INT_LITERAL  { $$ = new bi::Literal<int64_t>($1, yytext, new bi::AliasType(new bi::Name("Integer")), make_loc(@$)); }
    ;

real_literal
    : REAL_LITERAL  { $$ = new bi::Literal<double>($1, yytext, new bi::AliasType(new bi::Name("Real")), make_loc(@$)); }
    ;

string_literal
    : STRING_LITERAL  { $$ = new bi::Literal<const char*>($1, yytext, new bi::BasicType(new bi::Name("String")), make_loc(@$)); }
    ;

literal
    : bool_literal
    | int_literal
    | real_literal
    | string_literal
    ;

identifier
    : name  { $$ = new bi::Identifier<bi::Unknown>($1, make_loc(@$)); }
    ;

parens_expression
    : '(' expression ')'  { $$ = new bi::Parentheses($2, make_loc(@$)); }
    ;
    
function_expression
    : FUNCTION parameters optional_result optional_braces  { $$ = new bi::LambdaFunction($2, $3, $4, make_loc(@$)); }
    ;

this_expression
    : THIS  { $$ = new bi::This(make_loc(@$)); }
    ;

super_expression
    : SUPER  { $$ = new bi::Super(make_loc(@$)); }
    ;

primary_expression
    : literal
    | identifier
    | parens_expression
    | function_expression
    | this_expression
    | super_expression
    ;

index_expression
    : expression RANGE_OP expression  { $$ = new bi::Range($1, $3, make_loc(@$)); }
    | expression                      { $$ = new bi::Index($1, make_loc(@$)); }
    ;
    
index_list
    : index_expression
    | index_expression ',' index_list  { $$ = new bi::List<bi::Expression>($1, $3, make_loc(@$)); }
    ;

brackets_expression
    : '[' index_list ']'  { $$ = new bi::Brackets($2, make_loc(@$)); }
    ;

postfix_expression
    : primary_expression
    | postfix_expression brackets_expression  { $$ = new bi::Slice($1, $2, make_loc(@$)); }
    | postfix_expression arguments            { $$ = new bi::Call($1, $2, make_loc(@$)); }
    | postfix_expression '?'                  { $$ = new bi::Query($1, make_loc(@$)); }
    | postfix_expression '!'                  { $$ = new bi::Get($1, make_loc(@$)); }
    ;

member_operator
    : '.'
    ;

member_expression
    : postfix_expression
    | member_expression member_operator postfix_expression  { $$ = new bi::Member($1, $3, make_loc(@$)); }
    ;

prefix_operator
    : '+'  { $$ = new bi::OverloadedIdentifier<bi::UnaryOperator>(new bi::Name("+"), make_loc(@$)); }
    | '-'  { $$ = new bi::OverloadedIdentifier<bi::UnaryOperator>(new bi::Name("-"), make_loc(@$)); }
    | '!'  { $$ = new bi::OverloadedIdentifier<bi::UnaryOperator>(new bi::Name("!"), make_loc(@$)); }
    ;

prefix_expression
    : member_expression
    | prefix_operator prefix_expression  { $$ = new bi::UnaryCall($1, $2, make_loc(@$)); }
    ;

multiplicative_operator
    : '*'  { $$ = new bi::OverloadedIdentifier<bi::BinaryOperator>(new bi::Name("*"), make_loc(@$)); }
    | '/'  { $$ = new bi::OverloadedIdentifier<bi::BinaryOperator>(new bi::Name("/"), make_loc(@$)); }
    ;

multiplicative_expression
    : prefix_expression
    | multiplicative_expression multiplicative_operator prefix_expression  { $$ = new bi::BinaryCall($2, new bi::Binary($1, $3, make_loc(@$)), make_loc(@$)); }
    ;

additive_operator
    : '+'  { $$ = new bi::OverloadedIdentifier<bi::BinaryOperator>(new bi::Name("+"), make_loc(@$)); }
    | '-'  { $$ = new bi::OverloadedIdentifier<bi::BinaryOperator>(new bi::Name("-"), make_loc(@$)); }
    ;

additive_expression
    : multiplicative_expression
    | additive_expression additive_operator multiplicative_expression  { $$ = new bi::BinaryCall($2, new bi::Binary($1, $3, make_loc(@$)), make_loc(@$)); }
    ;

relational_operator
    : '<'    { $$ = new bi::OverloadedIdentifier<bi::BinaryOperator>(new bi::Name("<"), make_loc(@$)); }
    | '>'    { $$ = new bi::OverloadedIdentifier<bi::BinaryOperator>(new bi::Name(">"), make_loc(@$)); }
    | LE_OP  { $$ = new bi::OverloadedIdentifier<bi::BinaryOperator>(new bi::Name("<="), make_loc(@$)); }
    | GE_OP  { $$ = new bi::OverloadedIdentifier<bi::BinaryOperator>(new bi::Name(">="), make_loc(@$)); }
    ;
    
relational_expression
    : additive_expression
    | relational_expression relational_operator additive_expression  { $$ = new bi::BinaryCall($2, new bi::Binary($1, $3, make_loc(@$)), make_loc(@$)); }
    ;

equality_operator
    : EQ_OP  { $$ = new bi::OverloadedIdentifier<bi::BinaryOperator>(new bi::Name("=="), make_loc(@$)); }
    | NE_OP  { $$ = new bi::OverloadedIdentifier<bi::BinaryOperator>(new bi::Name("!="), make_loc(@$)); }
    ;

equality_expression
    : relational_expression
    | equality_expression equality_operator relational_expression  { $$ = new bi::BinaryCall($2, new bi::Binary($1, $3, make_loc(@$)), make_loc(@$)); }
    ;

logical_and_operator
    : AND_OP  { $$ = new bi::OverloadedIdentifier<bi::BinaryOperator>(new bi::Name("&&"), make_loc(@$)); }
    ;

logical_and_expression
    : equality_expression
    | logical_and_expression logical_and_operator equality_expression  { $$ = new bi::BinaryCall($2, new bi::Binary($1, $3, make_loc(@$)), make_loc(@$)); }
    ;

logical_or_operator
    : OR_OP  { $$ = new bi::OverloadedIdentifier<bi::BinaryOperator>(new bi::Name("||"), make_loc(@$)); }
    ;

logical_or_expression
    : logical_and_expression
    | logical_or_expression logical_or_operator logical_and_expression  { $$ = new bi::BinaryCall($2, new bi::Binary($1, $3, make_loc(@$)), make_loc(@$)); }
    ;

observe_operator
    : RIGHT_TILDE_OP  { $$ = new bi::OverloadedIdentifier<bi::BinaryOperator>(new bi::Name("~>"), make_loc(@$)); }
    ;

observe_expression
    : logical_or_expression
    | observe_expression observe_operator logical_or_expression  { $$ = new bi::BinaryCall($2, new bi::Binary($1, $3, make_loc(@$)), make_loc(@$)); }
    ;

expression_list
    : observe_expression
    | observe_expression ',' expression_list  { $$ = new bi::List<bi::Expression>($1, $3, make_loc(@$)); }
    ;

expression
    : observe_expression
    ;

parameters
    : '(' ')'                 { $$ = new bi::Parentheses(new bi::EmptyExpression(), make_loc(@$)); }
    | '(' parameter_list ')'  { $$ = new bi::Parentheses($2, make_loc(@$)); }
    ;

parameter_list
    : parameter
    | parameter ',' parameter_list  { $$ = new bi::List<bi::Expression>($1, $3, make_loc(@$)); }
    ;

parameter
    : name ':' type  { $$ = new bi::Parameter($1, $3, new bi::EmptyExpression(), make_loc(@$)); }
    ;

options
    : '(' ')'              { $$ = new bi::Parentheses(new bi::EmptyExpression(), make_loc(@$)); }
    | '(' option_list ')'  { $$ = new bi::Parentheses($2, make_loc(@$)); }
    ;

option_list
    : option
    | option ',' option_list  { $$ = new bi::List<bi::Expression>($1, $3, make_loc(@$)); }
    ;

option
    : name ':' type optional_value  { $$ = new bi::Parameter($1, $3, $4, make_loc(@$)); }
    ;

member_parameters
    : '(' ')'                        { $$ = new bi::Parentheses(new bi::EmptyExpression(), make_loc(@$)); }
    | '(' member_parameter_list ')'  { $$ = new bi::Parentheses($2, make_loc(@$)); }
    ;

optional_member_parameters
    : member_parameters
    |                    { $$ = new bi::EmptyExpression(); }
    ;

member_parameter_list
    : member_parameter
    | member_parameter ',' member_parameter_list  { $$ = new bi::List<bi::Expression>($1, $3, make_loc(@$)); }
    ;

member_parameter
    : name ':' type  { $$ = new bi::MemberParameter($1, $3, new bi::EmptyExpression(), make_loc(@$)); }
    ;

arguments
    : '(' ')'                  { $$ = new bi::Parentheses(new bi::EmptyExpression(), make_loc(@$)); }
    | '(' expression_list ')'  { $$ = new bi::Parentheses($2, make_loc(@$)); }
    ;
    ;

optional_arguments
    : arguments
    |            { $$ = new bi::EmptyExpression(); }
    ;

size
    : expression  { $$ = new bi::Span($1, make_loc(@$)); }
    | '_'         { $$ = new bi::Span(new bi::EmptyExpression(), make_loc(@$)); }
    ;

size_list
    : size
    | size ',' size_list  { $$ = new bi::List<bi::Expression>($1, $3, make_loc(@$)); }
    ;


/***************************************************************************
 * Statements                                                              *
 ***************************************************************************/

global_variable_declaration
    : name ':' type optional_arguments optional_value ';'  { $$ = new bi::GlobalVariable($1, $3, $4, $5, make_loc(@$)); }
    ;

local_variable_declaration
    : name ':' type optional_arguments optional_value ';'  { $$ = new bi::LocalVariable($1, $3, $4, $5, make_loc(@$)); }
    ;

member_variable_declaration
    : name ':' type optional_arguments optional_value ';'  { $$ = new bi::MemberVariable($1, $3, $4, $5, make_loc(@$)); }
    ;

function_declaration
    : FUNCTION name parameters optional_result optional_braces  { $$ = new bi::Function($2, $3, $4, $5, make_loc(@$)); }
    ;

coroutine_declaration
    : COROUTINE name parameters optional_result optional_braces  { $$ = new bi::Coroutine($2, $3, $4, $5, make_loc(@$)); }
    ;

program_declaration
    : PROGRAM name options optional_braces  { $$ = new bi::Program($2, $3, $4, make_loc(@$)); }
    ;

member_function_declaration
    : FUNCTION name parameters optional_result optional_braces  { $$ = new bi::MemberFunction($2, $3, $4, $5, make_loc(@$)); }
    ;

member_coroutine_declaration
    : COROUTINE name parameters optional_result optional_braces  { $$ = new bi::MemberCoroutine($2, $3, $4, $5, make_loc(@$)); }
    ;
    
binary_operator
    : '*'     { $$ = new bi::Name('*'); }
    | '/'     { $$ = new bi::Name('/'); }
    | '+'     { $$ = new bi::Name('+'); }
    | '-'     { $$ = new bi::Name('-'); }
    | '<'     { $$ = new bi::Name('<'); }
    | '>'     { $$ = new bi::Name('>'); }
    | LE_OP   { $$ = new bi::Name("<="); }
    | GE_OP   { $$ = new bi::Name(">="); }
    | EQ_OP   { $$ = new bi::Name("=="); }
    | NE_OP   { $$ = new bi::Name("!="); }
    | AND_OP  { $$ = new bi::Name("&&"); }
    | OR_OP   { $$ = new bi::Name("||"); }
    ;
    
binary_operator_declaration
    : OPERATOR parameter binary_operator parameter optional_result optional_braces  { $$ = new bi::BinaryOperator($3, new bi::Binary($2, $4, make_loc(@$)), $5, $6, make_loc(@$)); }
    ;

unary_operator
    : '+'  { $$ = new bi::Name('+'); }
    | '-'  { $$ = new bi::Name('-'); }
    | '!'  { $$ = new bi::Name('!'); }
    ;    

unary_operator_declaration
    : OPERATOR unary_operator parameter optional_result optional_braces  { $$ = new bi::UnaryOperator($2, $3, $4, $5, make_loc(@$)); }
    ;
    
assignment_operator
    : LEFT_OP        { $$ = new bi::Name("<-"); }
    | LEFT_TILDE_OP  { $$ = new bi::Name("<~"); }
    | '~'            { $$ = new bi::Name("~"); }
    ;

assignment_operator_declaration
    : OPERATOR LEFT_OP parameter optional_braces  { $$ = new bi::AssignmentOperator(new bi::Name("<-"), $3, $4, make_loc(@$)); }
    ;

conversion_operator_declaration
    : OPERATOR result optional_braces  { $$ = new bi::ConversionOperator($2, $3, make_loc(@$)); }
    ;

class_declaration
    : CLASS name optional_member_parameters '<' identifier_type optional_arguments optional_class_braces  { $$ = new bi::Class($2, $3, $5, $6, $7, make_loc(@$)); }
    | CLASS name optional_member_parameters optional_class_braces                                         { $$ = new bi::Class($2, $3, new bi::EmptyType(), new bi::EmptyExpression(), $4, make_loc(@$)); }
    ;

alias_type_declaration
    : TYPE name '=' identifier_type ';'  { $$ = new bi::Alias($2, $4, make_loc(@$)); }
    ;
    
basic_type_declaration
    : TYPE name ';'  { $$ = new bi::Basic($2, make_loc(@$)); }
    ;

import
    : IMPORT path ';'  { $$ = new bi::Import($2, compiler->import($2), make_loc(@$)); }
    ;

cpp
    : CPP double_braces  { $$ = new bi::Raw(new bi::Name("cpp"), raw.str(), make_loc(@$)); }
    ;

hpp
    : HPP double_braces  { $$ = new bi::Raw(new bi::Name("hpp"), raw.str(), make_loc(@$)); }
    ;

assignment
    : observe_expression assignment_operator observe_expression ';'  { $$ = new bi::Assignment($1, $2, $3, make_loc(@$)); }
    ;

expression_statement
    : expression ';'  { $$ = new bi::ExpressionStatement($1, make_loc(@$)); }
    ;

if
    : IF parens_expression braces ELSE braces  { $$ = new bi::If($2, $3, $5, make_loc(@$)); }
    | IF parens_expression braces ELSE if      { $$ = new bi::If($2, $3, $5, make_loc(@$)); }
    | IF parens_expression braces              { $$ = new bi::If($2, $3, new bi::EmptyStatement(), make_loc(@$)); }
    ;

for
    : FOR '(' identifier IN expression RANGE_OP expression ')' braces  { $$ = new bi::For($3, $5, $7, $9, make_loc(@$)); }
    ;

while
    : WHILE parens_expression braces  { $$ = new bi::While($2, $3, make_loc(@$)); }
    ;

assertion
    : ASSERT expression ';'  { $$ = new bi::Assert($2, make_loc(@$)); }
    ;

return
    : RETURN expression ';'  { $$ = new bi::Return($2, make_loc(@$)); }
    ;

yield
    : YIELD expression ';'  { $$ = new bi::Yield($2, make_loc(@$)); }
    ;

statement
    : local_variable_declaration
    | expression_statement
    | assignment
    | if
    | for
    | while
    | assertion
    | return
    | yield
    | cpp
    ;

statements
    : statement
    | statement statements  { $$ = new bi::List<bi::Statement>($1, $2, make_loc(@$)); }
    ;

optional_statements
    : statements
    |             { $$ = new bi::EmptyStatement(); }
    ;

class_statement
    : member_variable_declaration
    | member_function_declaration
    | member_coroutine_declaration
    | assignment_operator_declaration
    | conversion_operator_declaration
    | hpp
    ;
    
class_statements
    : class_statement
    | class_statement class_statements  { $$ = new bi::List<bi::Statement>($1, $2, make_loc(@$)); }
    ;
    
optional_class_statements
    : class_statements
    |                   { $$ = new bi::EmptyStatement(); }
    ;
    
file_statement
    : import
    | global_variable_declaration
    | function_declaration
    | coroutine_declaration
    | program_declaration
    | binary_operator_declaration
    | unary_operator_declaration
    | class_declaration
    | alias_type_declaration
    | basic_type_declaration
    | cpp
    | hpp
    ;

file_statements
    : file_statement
    | file_statement file_statements  { $$ = new bi::List<bi::Statement>($1, $2, make_loc(@$)); }
    ;

optional_file_statements
    : file_statements
    |                  { $$ = new bi::EmptyStatement(); }
    ;
    
file
    : optional_file_statements  { compiler->setRoot($1); }
    ;

result
    : RIGHT_OP type  { $$ = $2; }
    ;
    
optional_result
    : result
    |         { $$ = new bi::EmptyType(); }
    ;

value
    : LEFT_OP expression  { $$ = $2; }
    ;
    
optional_value
    : value
    |        { $$ = new bi::EmptyExpression(); }
    ;

braces
    : '{' optional_statements '}'  { $$ = $2; }
    ;

optional_braces
    : braces
    | ';'     { $$ = new bi::EmptyStatement(); }
    ;

class_braces
    : '{' optional_class_statements '}'  { $$ = $2; }
    ;

optional_class_braces
    : class_braces
    | ';'           { $$ = new bi::EmptyStatement(); }
    ;

raw
    : RAW      { raw << $1; }
    | raw RAW  { raw << $2; }
    ;
    
double_braces
    : DOUBLE_BRACE_OPEN { raw.str(""); } raw DOUBLE_BRACE_CLOSE
    ;


/***************************************************************************
 * Types                                                                   *
 ***************************************************************************/

identifier_type
    : name  { $$ = new bi::IdentifierType($1, make_loc(@$)); }
    ;

parens_type
    : '(' list_type ')'  { $$ = new bi::ParenthesesType($2, make_loc(@$)); }
    ;

function_type
    : FUNCTION_UPPER '<' type_parameters optional_result '>'  { $$ = new bi::FunctionType($3, $4, make_loc(@$)); }
    ;

primary_type
    : identifier_type
    | parens_type
    | function_type
    ;

postfix_type
    : primary_type
    | postfix_type '[' size_list ']'  { $$ = new bi::ArrayType($1, $3, make_loc(@$)); }
    | postfix_type '!'                { $$ = new bi::FiberType($1, make_loc(@$)); }
    | postfix_type '?'                { $$ = new bi::OptionalType($1, make_loc(@$)); }
    ;

list_type
    : postfix_type
    | postfix_type ',' list_type  { $$ = new bi::ListType($1, $3, make_loc(@$)); }
    ;

type
    : postfix_type
    ;

type_parameter_list
    : type
    | type ',' type_parameter_list  { $$ = new bi::ListType($1, $3, make_loc(@$)); }
    ;

type_parameters
    : '(' ')'                      { $$ = new bi::EmptyType(); }
    | '(' type_parameter_list ')'  { $$ = $2; }
    ;
    ;

%%
