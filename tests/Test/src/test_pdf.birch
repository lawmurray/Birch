function mean(x:Real[_]) -> Real {
  return sum(x)!/Real(length(x));
}

function cov(x:Real[_], μ:Real) -> Real {
  return dot(x - μ)!/(length(x) - 1.0);
}

function mean(X:Real[_,_]) -> Real[_] {
  return X*vector(1.0/columns(X), columns(X));
}

function cov(X:Real[_,_], μ:Real[_]) -> Real[_,_] {
  return outer(X - outer(μ, vector(1.0, columns(X))))/(columns(X) - 1.0);
}

/*
 * Test the pdf of a model.
 *
 * @param m The model.
 * @param N Number of samples.
 * @param lazy Use lazy version?
 */
function test_pdf<TestModelType>(m:TestModelType, N:Integer, lazy:Boolean) {
  with Handler(true, lazy, true) {
    m.initialize();
    m.simulate();
  }
  test_pdf(m.marginal(), N, lazy);
}

/*
 * Test the pdf of a model.
 *
 * @param m The model.
 * @param N Number of samples.
 * @param S Number of steps in each chain.
 * @param lazy Use lazy version?
 */
function test_pdf<TestModelType>(m:TestModelType, N:Integer, S:Integer,
    lazy:Boolean) {
  with Handler(true, lazy, true) {
    m.initialize();
    m.simulate();
  }
  test_pdf(m.marginal(), N, S, lazy);
}

/*
 * Test the pmf of a univariate Boolean distribution.
 *
 * @param π The target distribution. 
 * @param N Number of samples.
 * @param lazy Use lazy version?
 */
function test_pdf(π:Distribution<Boolean>, N:Integer, lazy:Boolean) {
  /* simulate, counting the occurrence of each value */
  k:Integer <- 0;
  for n in 1..N {
    if lazy {
      k <- k + π.simulateLazy()!;
    } else {
      k <- k + π.simulate()!;
    }
  }

  /* compare pdf to count */
  let failed <- false;
  let ε <- value(2.0/sqrt(N));
  let p <- 0.0;
  let q <- 0.0;
  if lazy {
    p <- π.logpdfLazy(true);
    q <- π.logpdfLazy(false);
  } else {
    p <- π.logpdf(true);
    q <- π.logpdf(false);
  }
  let δ <- value(abs(exp(p) - cast<Real>(k)/N));
  if 100 < N && !(δ <= ε) {  // careful of nans
    failed <- true;
    stderr.print("***failed*** on value true, " + δ + " > " + ε + "\n");
  }
  δ <- abs(exp(q) - cast<Real>(N - k)/N);
  if 100 < N && !(δ <= ε) {  // careful of nans
    failed <- true;
    stderr.print("***failed*** on value false, " + δ + " > " + ε + "\n");
  }
  if failed {
    exit(1);
  }

  /* smoke test for constant */
  π.fix();
}

/*
 * Test the pmf of a univariate discrete distribution.
 *
 * @param π The target distribution. 
 * @param N Number of samples.
 * @param lazy Use lazy version?
 */
function test_pdf(π:Distribution<Integer>, N:Integer, lazy:Boolean) {
  /* lower bound on interval */
  let from <- π.lower();
  if !from? {
    from <- π.quantile(1.0e-6);
    assert from?;
  }

  /* upper bound on interval */
  let to <- π.upper();
  if !to? {
    to <- π.quantile(1.0 - 1.0e-6);
    if !to? {
      /* search for a rough upper bound for the interval */
      let u <- 50;
      let p <- 0.0;
      do {
        u <- 2*u;
        if lazy {
          p <- π.logpdfLazy(u);
        } else {
          p <- π.logpdf(u);
        }
      } while p > log(1.0e-6);
      to <- u;
    }
  }

  /* simulate, counting the occurrence of each value */
  let count <- vector(0, to!! - from!! + 1);
  for n in 1..N {
    let j <- 0;
    if lazy {
      j <- π.simulateLazy();
    } else {
      j <- π.simulate();
    }
    let i <- j - from!! + 1;
    if 1 <= i && i <= length(count) {
      count[i] <- count[i] + 1;
    }
  }

  /* compare pdf to counts */
  let failed <- false;
  for x in from!!..to!! {
    let p <- 0.0;
    if lazy {
      p <- π.logpdfLazy(x);
    } else {
      p <- π.logpdf(x);
    }
    let δ <- value(abs(exp(p) - cast<Real>(count[x - from!! + 1])/N));
    let ε <- value(2.0/sqrt(N));
    if 100 < N && !(δ <= ε) {  // careful of nans
      failed <- true;
      stderr.print("***failed*** on value " + x + ", " + δ + " > " + ε + "\n");
    }
  }
  if failed {
    exit(1);
  }

  /* smoke test for constant */
  π.fix();
}

/*
 * Test a pdf.
 *
 * @param π The target distribution. 
 * @param N Number of (short) chains.
 * @param S Number of steps in each chain.
 */
function test_pdf(π:Distribution<Real>, N:Integer, S:Integer, lazy:Boolean) {
  /* iid samples */
  x1:Real[N];
  for n in 1..N {
    if lazy {
      x1[n] <- π.simulateLazy();
    } else {
      x1[n] <- π.simulate();
    }
  }
  
  /* compute the shape for a Gaussian proposal using iid samples */
  x:Real[N*S];
  for n in 1..N*S {
    if lazy {
      x[n] <- π.simulateLazy();
    } else {
      x[n] <- π.simulate();
    }
  }
  let μ <- mean(x);
  let σ2 <- cov(x, μ);

  /* draw Metropolis samples using pdf */
  x2:Real[N];
  let last <- false;  // are on the last iteration?
  let done <- false;  // are we done?
  do {
    let a <- vector(0, N);  // number of acceptances in each chain
    parallel for n in 1..N {
      /* initialize n-th chain */
      let x <- 0.0;
      let l <- 0.0;
      if lazy {
        x <- π.simulateLazy();
        l <- π.logpdfLazy(x);
      } else {
        x <- π.simulate();
        l <- π.logpdf(x);
      }

      /* step n-th chain S times */
      for s in 1..S {
        let x' <~ Gaussian(x, σ2);
        let l' <- 0.0;
        if lazy {
          l' <- π.logpdfLazy(x');
        } else {
          l' <- π.logpdf(x');
        }
        let u <~ Uniform(0.0, 1.0);
        if (log(u) <= l' - l)! {
          /* accept */
          x <- x';
          l <- l';
          a[n] <- a[n] + 1;
        }
      }

      /* final state */
      x2[n] <- x;
    }
    raccepts:Real <- sum(a)!/Real(N*S);  // overall acceptance rate
    if last {
      /* that was the last iteration, so now done */
      done <- true;
    } else if 100 < N && raccepts < 0.3 {
      /* acceptance rate too low, adapt */
      σ2 <- 0.5*σ2;
    } else if 100 < N && raccepts > 0.5 {
      /* acceptance rate too high, adapt */
      σ2 <- 1.5*σ2;
    } else {
      /* acceptance rate fine, repeat one last time to draw final sample */
      last <- true;
    }
  } while !done;
  
  /* test distance between the iid and Metropolis samples */
  if !pass(x1, x2) {
    exit(1);
  }

  /* smoke test for constant */
  π.fix();
}

/*
 * Test a multivariate pdf.
 *
 * @param π The target distribution. 
 * @param N Number of (short) chains.
 * @param S Number of steps in each chain.
 */
function test_pdf(π:Distribution<Real[_]>, N:Integer, S:Integer,
    lazy:Boolean) {
  /* iid samples */
  let D <- 0;
  if lazy {
    D <- rows(π.simulateLazy());
  } else {
    D <- rows(π.simulate());
  }
  X1:Real[D,N];
  parallel for n in 1..N {
    if lazy {
      X1[1..D,n] <- π.simulateLazy();
    } else {
      X1[1..D,n] <- π.simulate();
    }
  }
  
  /* compute the shape for a Gaussian proposal using iid samples */
  X:Real[D,N*D*S];
  parallel for n in 1..N*S*D {
    if lazy {
      X[1..D,n] <- π.simulateLazy();
    } else {
      X[1..D,n] <- π.simulate();
    }
  }
  let μ <- mean(X);
  let Σ <- cov(X, μ);
  
  /* draw Metropolis samples using pdf */
  X2:Real[D,N];
  let last <- false;  // are on the last iteration?
  let done <- false;  // are we done?
  do {
    let a <- vector(0, N);  // number of acceptances in each chain
    parallel for n in 1..N {
      /* initialize n-th chain */
      x:Real[_];
      let l <- 0.0;
      if lazy {
        x <- π.simulateLazy();
        l <- π.logpdfLazy(x);
      } else {
        x <- π.simulate();
        l <- π.logpdf(x);
      }

      /* step n-th chain S times */
      for s in 1..S {
        let x' <~ MultivariateGaussian(x, Σ);
        let l' <- 0.0;
        if lazy {
          l' <- π.logpdfLazy(x');
        } else {
          l' <- π.logpdf(x');
        }
        let u <~ Uniform(0.0, 1.0);
        if (log(u) <= l' - l)! {
          /* accept */
          x <- x';
          l <- l';
          a[n] <- a[n] + 1;
        }
      }

      /* final state */
      X2[1..D,n] <- x;
    }
    let raccepts <- sum(a)!/Real(N*S);  // overall acceptance rate
    if last {
      /* that was the last iteration, so now done */
      done <- true;
    } else if 100 < N && raccepts < 0.2 {
      /* acceptance rate too low, adapt */
      Σ <- 0.5*Σ;
    } else if 100 < N && raccepts > 0.25 {
      /* acceptance rate too high, adapt */
      Σ <- 1.5*Σ;
    } else {
      /* acceptance rate fine, repeat one last time to draw final sample */
      last <- true;
    }
  } while !done;

  /* test distance between the iid and Metropolis samples */
  if !pass(X1, X2) {
    exit(1);
  }

  /* smoke test for constant */
  π.fix();
}

/*
 * Test a matrix pdf.
 *
 * @param π The target distribution. 
 * @param N Number of (short) chains.
 * @param S Number of steps in each chain.
 * @param lazy Use lazy version?
 */
function test_pdf(π:Distribution<Real[_,_]>, N:Integer, S:Integer,
    lazy:Boolean) {
  let R <- 0;
  let C <- 0;
  if lazy {
    R <- rows(π.simulateLazy());
    C <- columns(π.simulateLazy());
  } else {
    R <- rows(π.simulate());
    C <- columns(π.simulate());
  }
  
  /* iid samples */
  X1:Real[R*C,N];
  parallel for n in 1..N {
    if lazy {
      X1[1..R*C,n] <- vec(π.simulateLazy());
    } else {
      X1[1..R*C,n] <- vec(π.simulate());
    }
  }
  
  /* compute the shape for a Gaussian proposal using iid samples */
  X:Real[R*C,N*S*R*C];
  parallel for n in 1..N*S*R*C {
    if lazy {
      X[1..R*C,n] <- vec(π.simulateLazy());
    } else {
      X[1..R*C,n] <- vec(π.simulate());
    }
  }
  let μ <- mean(X);
  let Σ <- cov(X, μ);

  /* draw Metropolis samples using pdf */
  X2:Real[R*C,N];
  let last <- false;  // are on the last iteration?
  let done <- false;  // are we done?
  do {
    let a <- vector(0, N);  // number of acceptances in each chain
    parallel for n in 1..N {
      /* initialize n-th chain */
      X:Real[_,_];
      let l <- 0.0;
      if lazy {
        X <- π.simulateLazy();
        l <- π.logpdfLazy(X);
      } else {
        X <- π.simulate();
        l <- π.logpdf(X);
      }

      /* step n-th chain S times */
      for s in 1..S {
        let x' <~ MultivariateGaussian(vec(X), Σ);
        let X' <- value(mat(x', C))!;
        let l' <- 0.0;
        if lazy {
          l' <- π.logpdfLazy(X');
        } else {
          l' <- π.logpdf(X');
        }
        let u <~ Uniform(0.0, 1.0);
        if (log(u) <= l' - l)! {
          /* accept */
          X <- X';
          l <- l';
          a[n] <- a[n] + 1;
        }
      }

      /* final state */
      X2[1..R*C,n] <- vec(X);
    }
    let raccepts <- value(sum(a)/Real(N*S))!;  // overall acceptance rate
    if last {
      /* that was the last iteration, so now done */
      done <- true;
    } else if 100 < N && raccepts < 0.2 {
      /* acceptance rate too low, adapt */
      Σ <- 0.5*Σ;
    } else if 100 < N && raccepts > 0.25 {
      /* acceptance rate too high, adapt */
      Σ <- 1.5*Σ;
    } else {
      /* acceptance rate fine, repeat one last time to draw final sample */
      last <- true;
    }
  } while !done;
  
  /* test distance between the iid and Metropolis samples */
  if !pass(X1, X2) {
    exit(1);
  }

  /* smoke test for constant */
  π.fix();
}
