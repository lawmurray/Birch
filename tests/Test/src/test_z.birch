/*
 * Test the normalizing constant of a model.
 *
 * @param m The model.
 * @param N Number of importance samples.
 * @param lazy Use lazy expressions?
 */
function test_z<TestModelType>(m:TestModelType, N:Integer, lazy:Boolean) {
  with construct<Handler>(true, lazy, true) {
    m.initialize();
    m.simulate();
  }
  test_z(m.marginal(), N, lazy);
}

/*
 * Test the normalizing constant of a pdf.
 *
 * @param π The target distribution. 
 * @param N Number of importance samples.
 * @param lazy Use lazy expressions?
 */
function test_z(π:Distribution<Real>, N:Integer, lazy:Boolean) {  
  /* create a t-distribution proposal using the mean and sample variance of
   * iid samples, calculated with Welford's online algorithm */
  let k <- 3.0;  // degrees of freedom
  let μ <- 0.0; // running mean
  let S <- 0.0; // running sum of squares of differences from mean
  for n in 1..N {
    let x <- π.simulate()!;
    let d <- x - μ;
    μ <- μ + d/n;
    S <- S + d*(x - μ);
  }
  let σ2 <- S*(k - 2)/N; // spread for Student's t proposal
  let q <- StudentT(k, μ, σ2);

  /* importance sample */
  z:Real[N];
  parallel for n in 1..N {
    if lazy {
      let x <- q.simulateLazy();
      z[n] <- π.logpdfLazy(x)! - q.logpdfLazy(x)!;
    } else {
      let x <- q.simulate();
      z[n] <- π.logpdf(x)! - q.logpdf(x)!;
    }
  }
  
  /* check difference in estimate */
  let (ess, lsum) <- resample_reduce(z);
  let δ <- abs(expm1(lsum - log(N)));
  let ε <- 10.0/sqrt(N);
  if !(N < 10 || δ < ε) {
    let Z <- exp(lsum - log(N));
    stderr.print("***failed*** Z=" + Z + ", ess=" + ess + "\n");
    exit(1);
  }

  /* smoke test for constant */
  π.fix();
}

/*
 * Test the normalizing constant of a pdf.
 *
 * @param π The target distribution. 
 * @param N Number of importance samples.
 * @param lazy Use lazy expressions?
 */
function test_z(π:Distribution<Real[_]>, N:Integer, lazy:Boolean) {
  let D <- rows(π.simulate());
  
  /* create a multivariate-t proposal using the mean and sample variance of
   * iid samples, calculated with Welford's online algorithm */
  let k <- 3.0; // degrees of freedom
  μ:Real[D];  // running mean
  M:Real[D,D];  // running matrix of co-moments
  Σ:Real[D,D];  // spread for multivariate-t proposal
  x:Real[_];
  d:Real[_];
  do {
    μ <- 0.0;
    M <- 0.0;
    for n in 1..N {
      x <- π.simulate();
      d <- x - μ;
      μ <- μ + d/n;
      M <- M + outer(d, x - μ);
    }
    Σ <- M*((k - 2)/N);
  } while N >= 10 && sum(isfinite(chol(Σ)))! == 0;
  let q <- MultivariateT(k, μ, Σ);

  /* draw importance samples */
  z:Real[N];
  parallel for n in 1..N {
    if lazy {
      let x <- q.simulateLazy();
      z[n] <- π.logpdfLazy(x)! - q.logpdfLazy(x)!;
    } else {
      let x <- q.simulate();
      z[n] <- π.logpdf(x)! - q.logpdf(x)!;
    }
  }
  
  /* check difference in estimate */
  let (ess, lsum) <- resample_reduce(z);
  let δ <- abs(expm1(lsum - log(N)));
  let ε <- 10.0/sqrt(N);
  if !(N < 10 || δ < ε) {
    let Z <- exp(lsum - log(N));
    stderr.print("***failed*** Z=" + Z + ", ess=" + ess + "\n");
    exit(1);
  }

  /* smoke test for constant */
  π.fix();
}

/*
 * Test the normalizing constant of a pdf.
 *
 * @param π The target distribution. 
 * @param N Number of importance samples.
 * @param lazy Use lazy expressions?
 */
function test_z(π:Distribution<Real[_,_]>, N:Integer, lazy:Boolean) {
  let R <- rows(π.simulate());
  let C <- columns(π.simulate());
  let D <- R*C;

  /* create a multivariate-t proposal using the mean and sample variance of
   * iid samples, calculated with Welford's online algorithm */
  let k <- 3.0; // degrees of freedom
  μ:Real[D];  // running mean
  M:Real[D,D];  // running matrix of co-moments
  Σ:Real[D,D];  // spread for multivariate-t proposal
  x:Real[_];
  d:Real[_];
  do {
    μ <- 0.0;
    M <- 0.0;
    for n in 1..N {
      x <- vec(π.simulate());
      d <- x - μ;
      μ <- μ + d/n;
      M <- M + outer(d, x - μ);
    }
    Σ <- M*((k - 2)/N);
  } while N >= 10 && sum(isfinite(chol(Σ)))! == 0;
  let q <- MultivariateT(k, μ, Σ);

  /* draw importance samples */
  z:Real[N];
  parallel for n in 1..N {
    if lazy {
      let x <- q.simulateLazy();
      z[n] <- π.logpdfLazy(mat(x, C))! - q.logpdfLazy(x)!;
    } else {
      let x <- q.simulate();
      z[n] <- π.logpdf(mat(x, C))! - q.logpdf(x)!;
    }
  }
  
  /* check difference in estimate */
  let (ess, lsum) <- resample_reduce(z);
  let δ <- abs(expm1(lsum - log(N)));
  let ε <- 10.0/sqrt(N);
  if !(N < 10 || δ < ε) {
    let Z <- exp(lsum - log(N));
    stderr.print("***failed*** Z=" + Z + ", ess=" + ess + "\n");
    exit(1);
  }

  /* smoke test for constant */
  π.fix();
}
